CCS PCM C Compiler, Version 5.015, 5967               03-Dec-23 19:03

               Filename:   C:\Users\soyan\proyectos_programacion\7_MM\pf\pf.lst

               ROM used:   3935 words (48%)
                           Largest free fragment is 2048
               RAM used:   40 (11%) at main() level
                           86 (23%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   28F
0003:  NOP
.................... #include<16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 0C,29
0005:  DATA E5,30
0006:  DATA E4,3C
0007:  DATA 2E,17
0008:  DATA 2E,05
0009:  DATA 00,00
000A:  DATA D3,32
000B:  DATA EC,32
000C:  DATA E3,31
000D:  DATA E9,37
000E:  DATA 6E,10
000F:  DATA ED,37
0010:  DATA E4,37
0011:  DATA 00,01
0012:  DATA 61,1D
0013:  DATA C1,3A
0014:  DATA F4,37
0015:  DATA 20,3E
0016:  DATA 20,31
0017:  DATA BA,26
0018:  DATA 61,37
0019:  DATA 00,01
001A:  DATA 6D,1D
001B:  DATA C1,3A
001C:  DATA F4,37
001D:  DATA 00,01
001E:  DATA D0,3A
001F:  DATA 65,1D
0020:  DATA 4F,38
0021:  DATA 65,37
0022:  DATA 8A,06
0023:  DATA 00,01
0024:  DATA D0,3A
0025:  DATA 65,1D
0026:  DATA 43,36
0027:  DATA EF,39
0028:  DATA 65,00
0029:  DATA 56,1D
002A:  DATA 4F,27
002B:  DATA 00,01
002C:  DATA D4,32
002D:  DATA 6D,38
002E:  DATA 65,39
002F:  DATA 61,3A
0030:  DATA 75,39
0031:  DATA 61,10
0032:  DATA A8,21
0033:  DATA 29,1D
0034:  DATA A0,12
0035:  DATA AE,18
0036:  DATA 66,10
0037:  DATA A8,21
0038:  DATA 29,10
0039:  DATA 20,3E
003A:  DATA 20,10
003B:  DATA 20,28
003C:  DATA F5,32
003D:  DATA 72,3A
003E:  DATA 61,1D
003F:  DATA A0,12
0040:  DATA 75,10
0041:  DATA 20,10
0042:  DATA 7C,10
0043:  DATA 20,10
0044:  DATA D6,32
0045:  DATA 6E,3A
0046:  DATA 69,36
0047:  DATA 61,32
0048:  DATA 6F,39
0049:  DATA 3A,10
004A:  DATA 4F,27
004B:  DATA 8A,06
004C:  DATA 00,00
004D:  DATA 56,1D
004E:  DATA 4F,27
004F:  DATA 00,01
0050:  DATA D4,32
0051:  DATA 6D,38
0052:  DATA 65,39
0053:  DATA 61,3A
0054:  DATA 75,39
0055:  DATA 61,10
0056:  DATA A8,21
0057:  DATA 29,1D
0058:  DATA A0,12
0059:  DATA AE,18
005A:  DATA 66,10
005B:  DATA A8,21
005C:  DATA 29,14
005D:  DATA 50,39
005E:  DATA E5,31
005F:  DATA E1,3A
0060:  DATA E3,34
0061:  DATA 6F,37
0062:  DATA 29,3E
0063:  DATA D0,3A
0064:  DATA 65,39
0065:  DATA F4,30
0066:  DATA 3A,10
0067:  DATA A5,3A
0068:  DATA 7C,2B
0069:  DATA 65,37
006A:  DATA F4,34
006B:  DATA EC,30
006C:  DATA E4,37
006D:  DATA 72,1D
006E:  DATA A0,27
006F:  DATA 4E,05
0070:  DATA 0D,00
0071:  DATA 56,1D
0072:  DATA 4F,23
0073:  DATA 46,00
0074:  DATA D4,32
0075:  DATA 6D,38
0076:  DATA 65,39
0077:  DATA 61,3A
0078:  DATA 75,39
0079:  DATA 61,10
007A:  DATA A8,21
007B:  DATA 29,1D
007C:  DATA A0,12
007D:  DATA AE,18
007E:  DATA 66,10
007F:  DATA A8,21
0080:  DATA 29,10
0081:  DATA 20,10
0082:  DATA 7C,10
0083:  DATA 20,10
0084:  DATA D0,3A
0085:  DATA 65,39
0086:  DATA F4,30
0087:  DATA 3A,10
0088:  DATA A5,3A
0089:  DATA 20,10
008A:  DATA 20,3E
008B:  DATA 20,10
008C:  DATA 20,2B
008D:  DATA 65,37
008E:  DATA F4,34
008F:  DATA EC,30
0090:  DATA E4,37
0091:  DATA 72,1D
0092:  DATA A0,27
0093:  DATA 46,23
0094:  DATA 8A,06
0095:  DATA 00,01
0096:  DATA 54,1D
0097:  DATA CE,20
0098:  DATA 00,01
0099:  DATA C4,22
009A:  DATA D3,21
009B:  DATA 4F,27
009C:  DATA C5,21
009D:  DATA D4,20
009E:  DATA C4,27
009F:  DATA 8A,06
00A0:  DATA 00,00
00A1:  DATA 6D,1D
00A2:  DATA CD,30
00A3:  DATA EE,3A
00A4:  DATA 00,01
00A5:  DATA D4,32
00A6:  DATA 6D,38
00A7:  DATA 65,39
00A8:  DATA 61,3A
00A9:  DATA 75,39
00AA:  DATA 61,10
00AB:  DATA A8,21
00AC:  DATA 29,1D
00AD:  DATA A0,12
00AE:  DATA AE,18
00AF:  DATA 66,10
00B0:  DATA A8,21
00B1:  DATA 29,10
00B2:  DATA 20,10
00B3:  DATA 7C,10
00B4:  DATA 20,10
00B5:  DATA D0,3A
00B6:  DATA 65,39
00B7:  DATA F4,30
00B8:  DATA 3A,10
00B9:  DATA A5,3A
00BA:  DATA 20,10
00BB:  DATA 20,3E
00BC:  DATA 20,10
00BD:  DATA 20,2B
00BE:  DATA 65,37
00BF:  DATA F4,34
00C0:  DATA EC,30
00C1:  DATA E4,37
00C2:  DATA 72,1D
00C3:  DATA A0,27
00C4:  DATA 46,23
00C5:  DATA 8A,06
00C6:  DATA 00,01
00C7:  DATA 56,1D
00C8:  DATA 4F,23
00C9:  DATA 46,00
00CA:  DATA 54,1D
00CB:  DATA CE,20
00CC:  DATA 00,01
00CD:  DATA C4,22
00CE:  DATA D3,21
00CF:  DATA 4F,27
00D0:  DATA C5,21
00D1:  DATA D4,20
00D2:  DATA C4,27
00D3:  DATA 8A,06
00D4:  DATA 00,01
00D5:  DATA 6D,1D
00D6:  DATA CD,30
00D7:  DATA EE,3A
00D8:  DATA 00,01
00D9:  DATA D4,32
00DA:  DATA 6D,38
00DB:  DATA 65,39
00DC:  DATA 61,3A
00DD:  DATA 75,39
00DE:  DATA 61,10
00DF:  DATA A8,21
00E0:  DATA 29,1D
00E1:  DATA A0,12
00E2:  DATA AE,18
00E3:  DATA 66,10
00E4:  DATA A8,21
00E5:  DATA 29,10
00E6:  DATA 20,3E
00E7:  DATA 20,10
00E8:  DATA 20,28
00E9:  DATA F5,32
00EA:  DATA 72,3A
00EB:  DATA 61,1D
00EC:  DATA A0,12
00ED:  DATA 75,10
00EE:  DATA 20,10
00EF:  DATA 7C,10
00F0:  DATA 20,10
00F1:  DATA D6,32
00F2:  DATA 6E,3A
00F3:  DATA 69,36
00F4:  DATA 61,32
00F5:  DATA 6F,39
00F6:  DATA 3A,10
00F7:  DATA 4F,27
00F8:  DATA 8A,06
00F9:  DATA 00,01
00FA:  DATA 56,1D
00FB:  DATA 4F,27
00FC:  DATA 00,01
00FD:  DATA 54,1D
00FE:  DATA CE,20
00FF:  DATA 00,01
0100:  DATA C4,22
0101:  DATA D3,21
0102:  DATA 4F,27
0103:  DATA C5,21
0104:  DATA D4,20
0105:  DATA C4,27
0106:  DATA 8A,06
0107:  DATA 00,00
*
01EB:  MOVF   0B,W
01EC:  MOVWF  3F
01ED:  BCF    0B.7
01EE:  BSF    03.5
01EF:  BSF    03.6
01F0:  BSF    0C.7
01F1:  BSF    0C.0
01F2:  NOP
01F3:  NOP
01F4:  BCF    03.5
01F5:  BCF    03.6
01F6:  BTFSC  3F.7
01F7:  BSF    0B.7
01F8:  BSF    03.6
01F9:  MOVF   0C,W
01FA:  ANDLW  7F
01FB:  BTFSC  03.2
01FC:  GOTO   23F
01FD:  BCF    03.6
01FE:  MOVWF  3F
01FF:  BSF    03.6
0200:  MOVF   0D,W
0201:  BCF    03.6
0202:  MOVWF  40
0203:  BSF    03.6
0204:  MOVF   0F,W
0205:  BCF    03.6
0206:  MOVWF  41
0207:  MOVF   3F,W
0208:  MOVWF  4C
0209:  CALL   1BF
020A:  MOVF   40,W
020B:  BSF    03.6
020C:  MOVWF  0D
020D:  BCF    03.6
020E:  MOVF   41,W
020F:  BSF    03.6
0210:  MOVWF  0F
0211:  BCF    03.6
0212:  MOVF   0B,W
0213:  MOVWF  42
0214:  BCF    0B.7
0215:  BSF    03.5
0216:  BSF    03.6
0217:  BSF    0C.7
0218:  BSF    0C.0
0219:  NOP
021A:  NOP
021B:  BCF    03.5
021C:  BCF    03.6
021D:  BTFSC  42.7
021E:  BSF    0B.7
021F:  BSF    03.6
0220:  RLF    0C,W
0221:  RLF    0E,W
0222:  ANDLW  7F
0223:  BTFSC  03.2
0224:  GOTO   23F
0225:  BCF    03.6
0226:  MOVWF  3F
0227:  BSF    03.6
0228:  MOVF   0D,W
0229:  BCF    03.6
022A:  MOVWF  40
022B:  BSF    03.6
022C:  MOVF   0F,W
022D:  BCF    03.6
022E:  MOVWF  41
022F:  MOVF   3F,W
0230:  MOVWF  4C
0231:  CALL   1BF
0232:  MOVF   40,W
0233:  BSF    03.6
0234:  MOVWF  0D
0235:  BCF    03.6
0236:  MOVF   41,W
0237:  BSF    03.6
0238:  MOVWF  0F
0239:  INCF   0D,F
023A:  BTFSC  03.2
023B:  INCF   0F,F
023C:  BCF    03.6
023D:  GOTO   1EB
023E:  BSF    03.6
023F:  BCF    03.6
0240:  RETURN
*
0279:  MOVF   53,W
027A:  CLRF   78
027B:  SUBWF  52,W
027C:  BTFSC  03.0
027D:  GOTO   281
027E:  MOVF   52,W
027F:  MOVWF  77
0280:  GOTO   28D
0281:  CLRF   77
0282:  MOVLW  08
0283:  MOVWF  54
0284:  RLF    52,F
0285:  RLF    77,F
0286:  MOVF   53,W
0287:  SUBWF  77,W
0288:  BTFSC  03.0
0289:  MOVWF  77
028A:  RLF    78,F
028B:  DECFSZ 54,F
028C:  GOTO   284
028D:  RETURN
028E:  MOVF   2C,W
028F:  MOVWF  04
0290:  BCF    03.7
0291:  BTFSC  2D.0
0292:  BSF    03.7
0293:  MOVF   52,W
0294:  MOVWF  00
0295:  INCF   04,F
0296:  CLRF   00
0297:  INCF   2C,F
0298:  BTFSC  03.2
0299:  INCF   2D,F
029A:  RETURN
029B:  MOVLW  20
029C:  BTFSS  4D.4
029D:  MOVLW  30
029E:  MOVWF  4E
029F:  MOVF   4C,W
02A0:  MOVWF  77
02A1:  BTFSS  4C.7
02A2:  GOTO   2AB
02A3:  COMF   77,F
02A4:  INCF   77,F
02A5:  MOVF   77,W
02A6:  MOVWF  4C
02A7:  MOVLW  2D
02A8:  MOVWF  4E
02A9:  BSF    4D.7
02AA:  BSF    4D.0
02AB:  MOVF   4C,W
02AC:  MOVWF  52
02AD:  MOVLW  64
02AE:  MOVWF  53
02AF:  CALL   279
02B0:  MOVF   77,W
02B1:  MOVWF  4C
02B2:  MOVLW  30
02B3:  ADDWF  78,W
02B4:  MOVWF  4F
02B5:  MOVF   4C,W
02B6:  MOVWF  52
02B7:  MOVLW  0A
02B8:  MOVWF  53
02B9:  CALL   279
02BA:  MOVLW  30
02BB:  ADDWF  77,W
02BC:  MOVWF  51
02BD:  MOVLW  30
02BE:  ADDWF  78,W
02BF:  MOVWF  50
02C0:  MOVF   4E,W
02C1:  MOVWF  77
02C2:  MOVLW  30
02C3:  SUBWF  4F,W
02C4:  BTFSC  03.2
02C5:  GOTO   2CA
02C6:  BSF    4D.1
02C7:  BTFSC  4D.7
02C8:  BSF    4D.2
02C9:  GOTO   2DE
02CA:  MOVF   4E,W
02CB:  MOVWF  4F
02CC:  MOVLW  20
02CD:  MOVWF  4E
02CE:  MOVLW  30
02CF:  SUBWF  50,W
02D0:  BTFSC  03.2
02D1:  GOTO   2D6
02D2:  BSF    4D.0
02D3:  BTFSC  4D.7
02D4:  BSF    4D.1
02D5:  GOTO   2DE
02D6:  BTFSS  03.2
02D7:  BSF    4D.0
02D8:  BTFSS  03.2
02D9:  GOTO   2DE
02DA:  MOVF   4F,W
02DB:  MOVWF  50
02DC:  MOVLW  20
02DD:  MOVWF  4F
02DE:  BTFSC  4D.2
02DF:  GOTO   2E5
02E0:  BTFSC  4D.1
02E1:  GOTO   2E8
02E2:  BTFSC  4D.0
02E3:  GOTO   2EB
02E4:  GOTO   2EE
02E5:  MOVF   4E,W
02E6:  MOVWF  52
02E7:  CALL   28E
02E8:  MOVF   4F,W
02E9:  MOVWF  52
02EA:  CALL   28E
02EB:  MOVF   50,W
02EC:  MOVWF  52
02ED:  CALL   28E
02EE:  MOVF   51,W
02EF:  MOVWF  52
02F0:  CALL   28E
02F1:  RETURN
02F2:  MOVF   5D,W
02F3:  BTFSC  03.2
02F4:  GOTO   362
02F5:  MOVWF  65
02F6:  MOVF   61,W
02F7:  BTFSC  03.2
02F8:  GOTO   362
02F9:  ADDWF  65,F
02FA:  BTFSC  03.0
02FB:  GOTO   303
02FC:  MOVLW  7F
02FD:  SUBWF  65,F
02FE:  BTFSS  03.0
02FF:  GOTO   362
0300:  BTFSC  03.2
0301:  GOTO   362
0302:  GOTO   307
0303:  MOVLW  81
0304:  ADDWF  65,F
0305:  BTFSC  03.0
0306:  GOTO   362
0307:  MOVF   65,W
0308:  MOVWF  77
0309:  CLRF   78
030A:  CLRF   79
030B:  CLRF   7A
030C:  MOVF   5E,W
030D:  MOVWF  69
030E:  BSF    69.7
030F:  MOVF   5F,W
0310:  MOVWF  68
0311:  MOVF   60,W
0312:  MOVWF  67
0313:  MOVLW  18
0314:  MOVWF  65
0315:  CLRF   66
0316:  BTFSS  67.0
0317:  GOTO   330
0318:  MOVF   64,W
0319:  ADDWF  7A,F
031A:  BTFSS  03.0
031B:  GOTO   322
031C:  INCF   79,F
031D:  BTFSS  03.2
031E:  GOTO   322
031F:  INCF   78,F
0320:  BTFSC  03.2
0321:  BSF    66.7
0322:  MOVF   63,W
0323:  ADDWF  79,F
0324:  BTFSS  03.0
0325:  GOTO   329
0326:  INCF   78,F
0327:  BTFSC  03.2
0328:  BSF    66.7
0329:  MOVF   62,W
032A:  MOVWF  5F
032B:  BSF    5F.7
032C:  MOVF   5F,W
032D:  ADDWF  78,F
032E:  BTFSC  03.0
032F:  BSF    66.7
0330:  RLF    66,F
0331:  RRF    78,F
0332:  RRF    79,F
0333:  RRF    7A,F
0334:  RRF    69,F
0335:  RRF    68,F
0336:  RRF    67,F
0337:  BCF    03.0
0338:  DECFSZ 65,F
0339:  GOTO   315
033A:  MOVLW  01
033B:  ADDWF  77,F
033C:  BTFSC  03.0
033D:  GOTO   362
033E:  BTFSC  78.7
033F:  GOTO   347
0340:  RLF    69,F
0341:  RLF    7A,F
0342:  RLF    79,F
0343:  RLF    78,F
0344:  DECF   77,F
0345:  BTFSC  03.2
0346:  GOTO   362
0347:  BTFSS  69.7
0348:  GOTO   358
0349:  INCF   7A,F
034A:  BTFSS  03.2
034B:  GOTO   358
034C:  INCF   79,F
034D:  BTFSS  03.2
034E:  GOTO   358
034F:  INCF   78,F
0350:  BTFSS  03.2
0351:  GOTO   358
0352:  RRF    78,F
0353:  RRF    79,F
0354:  RRF    7A,F
0355:  INCF   77,F
0356:  BTFSC  03.2
0357:  GOTO   362
0358:  MOVF   5E,W
0359:  MOVWF  66
035A:  MOVF   62,W
035B:  XORWF  66,F
035C:  BTFSS  66.7
035D:  GOTO   360
035E:  BSF    78.7
035F:  GOTO   366
0360:  BCF    78.7
0361:  GOTO   366
0362:  CLRF   77
0363:  CLRF   78
0364:  CLRF   79
0365:  CLRF   7A
0366:  RETURN
0367:  MOVLW  8E
0368:  MOVWF  77
0369:  MOVF   62,W
036A:  MOVWF  78
036B:  MOVF   61,W
036C:  MOVWF  79
036D:  CLRF   7A
036E:  MOVF   78,F
036F:  BTFSS  03.2
0370:  GOTO   37B
0371:  MOVF   79,W
0372:  MOVWF  78
0373:  CLRF   79
0374:  MOVLW  08
0375:  SUBWF  77,F
0376:  MOVF   78,F
0377:  BTFSS  03.2
0378:  GOTO   37B
0379:  CLRF   77
037A:  GOTO   383
037B:  BCF    03.0
037C:  BTFSC  78.7
037D:  GOTO   382
037E:  RLF    79,F
037F:  RLF    78,F
0380:  DECF   77,F
0381:  GOTO   37B
0382:  BCF    78.7
0383:  RETURN
0384:  MOVF   61,W
0385:  BTFSC  03.2
0386:  GOTO   449
0387:  MOVWF  6D
0388:  MOVF   65,W
0389:  BTFSC  03.2
038A:  GOTO   449
038B:  SUBWF  6D,F
038C:  BTFSS  03.0
038D:  GOTO   393
038E:  MOVLW  7F
038F:  ADDWF  6D,F
0390:  BTFSC  03.0
0391:  GOTO   449
0392:  GOTO   399
0393:  MOVLW  81
0394:  SUBWF  6D,F
0395:  BTFSS  03.0
0396:  GOTO   449
0397:  BTFSC  03.2
0398:  GOTO   449
0399:  MOVF   6D,W
039A:  MOVWF  77
039B:  CLRF   78
039C:  CLRF   79
039D:  CLRF   7A
039E:  CLRF   6C
039F:  MOVF   62,W
03A0:  MOVWF  6B
03A1:  BSF    6B.7
03A2:  MOVF   63,W
03A3:  MOVWF  6A
03A4:  MOVF   64,W
03A5:  MOVWF  69
03A6:  MOVLW  19
03A7:  MOVWF  6D
03A8:  MOVF   68,W
03A9:  SUBWF  69,F
03AA:  BTFSC  03.0
03AB:  GOTO   3BC
03AC:  MOVLW  01
03AD:  SUBWF  6A,F
03AE:  BTFSC  03.0
03AF:  GOTO   3BC
03B0:  SUBWF  6B,F
03B1:  BTFSC  03.0
03B2:  GOTO   3BC
03B3:  SUBWF  6C,F
03B4:  BTFSC  03.0
03B5:  GOTO   3BC
03B6:  INCF   6C,F
03B7:  INCF   6B,F
03B8:  INCF   6A,F
03B9:  MOVF   68,W
03BA:  ADDWF  69,F
03BB:  GOTO   3EE
03BC:  MOVF   67,W
03BD:  SUBWF  6A,F
03BE:  BTFSC  03.0
03BF:  GOTO   3D7
03C0:  MOVLW  01
03C1:  SUBWF  6B,F
03C2:  BTFSC  03.0
03C3:  GOTO   3D7
03C4:  SUBWF  6C,F
03C5:  BTFSC  03.0
03C6:  GOTO   3D7
03C7:  INCF   6C,F
03C8:  INCF   6B,F
03C9:  MOVF   67,W
03CA:  ADDWF  6A,F
03CB:  MOVF   68,W
03CC:  ADDWF  69,F
03CD:  BTFSS  03.0
03CE:  GOTO   3EE
03CF:  INCF   6A,F
03D0:  BTFSS  03.2
03D1:  GOTO   3EE
03D2:  INCF   6B,F
03D3:  BTFSS  03.2
03D4:  GOTO   3EE
03D5:  INCF   6C,F
03D6:  GOTO   3EE
03D7:  MOVF   66,W
03D8:  IORLW  80
03D9:  SUBWF  6B,F
03DA:  BTFSC  03.0
03DB:  GOTO   3ED
03DC:  MOVLW  01
03DD:  SUBWF  6C,F
03DE:  BTFSC  03.0
03DF:  GOTO   3ED
03E0:  INCF   6C,F
03E1:  MOVF   66,W
03E2:  IORLW  80
03E3:  ADDWF  6B,F
03E4:  MOVF   67,W
03E5:  ADDWF  6A,F
03E6:  BTFSS  03.0
03E7:  GOTO   3CB
03E8:  INCF   6B,F
03E9:  BTFSS  03.2
03EA:  GOTO   3CB
03EB:  INCF   6C,F
03EC:  GOTO   3CB
03ED:  BSF    7A.0
03EE:  DECFSZ 6D,F
03EF:  GOTO   3F1
03F0:  GOTO   3FC
03F1:  BCF    03.0
03F2:  RLF    69,F
03F3:  RLF    6A,F
03F4:  RLF    6B,F
03F5:  RLF    6C,F
03F6:  BCF    03.0
03F7:  RLF    7A,F
03F8:  RLF    79,F
03F9:  RLF    78,F
03FA:  RLF    6E,F
03FB:  GOTO   3A8
03FC:  BTFSS  6E.0
03FD:  GOTO   404
03FE:  BCF    03.0
03FF:  RRF    78,F
0400:  RRF    79,F
0401:  RRF    7A,F
0402:  RRF    6E,F
0403:  GOTO   407
0404:  DECF   77,F
0405:  BTFSC  03.2
0406:  GOTO   449
0407:  BTFSC  6E.7
0408:  GOTO   430
0409:  BCF    03.0
040A:  RLF    69,F
040B:  RLF    6A,F
040C:  RLF    6B,F
040D:  RLF    6C,F
040E:  MOVF   68,W
040F:  SUBWF  69,F
0410:  BTFSC  03.0
0411:  GOTO   41C
0412:  MOVLW  01
0413:  SUBWF  6A,F
0414:  BTFSC  03.0
0415:  GOTO   41C
0416:  SUBWF  6B,F
0417:  BTFSC  03.0
0418:  GOTO   41C
0419:  SUBWF  6C,F
041A:  BTFSS  03.0
041B:  GOTO   43F
041C:  MOVF   67,W
041D:  SUBWF  6A,F
041E:  BTFSC  03.0
041F:  GOTO   427
0420:  MOVLW  01
0421:  SUBWF  6B,F
0422:  BTFSC  03.0
0423:  GOTO   427
0424:  SUBWF  6C,F
0425:  BTFSS  03.0
0426:  GOTO   43F
0427:  MOVF   66,W
0428:  IORLW  80
0429:  SUBWF  6B,F
042A:  BTFSC  03.0
042B:  GOTO   430
042C:  MOVLW  01
042D:  SUBWF  6C,F
042E:  BTFSS  03.0
042F:  GOTO   43F
0430:  INCF   7A,F
0431:  BTFSS  03.2
0432:  GOTO   43F
0433:  INCF   79,F
0434:  BTFSS  03.2
0435:  GOTO   43F
0436:  INCF   78,F
0437:  BTFSS  03.2
0438:  GOTO   43F
0439:  INCF   77,F
043A:  BTFSC  03.2
043B:  GOTO   449
043C:  RRF    78,F
043D:  RRF    79,F
043E:  RRF    7A,F
043F:  MOVF   62,W
0440:  MOVWF  6D
0441:  MOVF   66,W
0442:  XORWF  6D,F
0443:  BTFSS  6D.7
0444:  GOTO   447
0445:  BSF    78.7
0446:  GOTO   44D
0447:  BCF    78.7
0448:  GOTO   44D
0449:  CLRF   77
044A:  CLRF   78
044B:  CLRF   79
044C:  CLRF   7A
044D:  RETURN
044E:  MOVLW  80
044F:  BTFSC  03.1
0450:  XORWF  66,F
0451:  CLRF   6B
0452:  CLRF   6C
0453:  MOVF   62,W
0454:  MOVWF  6A
0455:  MOVF   66,W
0456:  XORWF  6A,F
0457:  MOVF   61,W
0458:  BTFSC  03.2
0459:  GOTO   53E
045A:  MOVWF  69
045B:  MOVWF  77
045C:  MOVF   65,W
045D:  BTFSC  03.2
045E:  GOTO   547
045F:  SUBWF  69,F
0460:  BTFSC  03.2
0461:  GOTO   4E3
0462:  BTFSS  03.0
0463:  GOTO   4A1
0464:  MOVF   66,W
0465:  MOVWF  6F
0466:  BSF    6F.7
0467:  MOVF   67,W
0468:  MOVWF  6E
0469:  MOVF   68,W
046A:  MOVWF  6D
046B:  CLRF   6C
046C:  BCF    03.0
046D:  RRF    6F,F
046E:  RRF    6E,F
046F:  RRF    6D,F
0470:  RRF    6C,F
0471:  DECFSZ 69,F
0472:  GOTO   46B
0473:  BTFSS  6A.7
0474:  GOTO   478
0475:  BSF    6B.0
0476:  GOTO   55B
0477:  BCF    6B.0
0478:  BCF    69.0
0479:  BSF    6B.4
047A:  MOVLW  64
047B:  MOVWF  04
047C:  BCF    03.7
047D:  GOTO   570
047E:  BCF    6B.4
047F:  BTFSC  6A.7
0480:  GOTO   48B
0481:  BTFSS  69.0
0482:  GOTO   496
0483:  RRF    6F,F
0484:  RRF    6E,F
0485:  RRF    6D,F
0486:  RRF    6C,F
0487:  INCF   77,F
0488:  BTFSC  03.2
0489:  GOTO   556
048A:  GOTO   496
048B:  BTFSC  6F.7
048C:  GOTO   499
048D:  BCF    03.0
048E:  RLF    6C,F
048F:  RLF    6D,F
0490:  RLF    6E,F
0491:  RLF    6F,F
0492:  DECF   77,F
0493:  BTFSC  03.2
0494:  GOTO   556
0495:  GOTO   48B
0496:  BSF    6B.6
0497:  GOTO   503
0498:  BCF    6B.6
0499:  MOVF   62,W
049A:  MOVWF  6A
049B:  BTFSS  6A.7
049C:  GOTO   49F
049D:  BSF    6F.7
049E:  GOTO   54F
049F:  BCF    6F.7
04A0:  GOTO   54F
04A1:  MOVF   65,W
04A2:  MOVWF  69
04A3:  MOVWF  77
04A4:  MOVF   61,W
04A5:  SUBWF  69,F
04A6:  MOVF   62,W
04A7:  MOVWF  6F
04A8:  BSF    6F.7
04A9:  MOVF   63,W
04AA:  MOVWF  6E
04AB:  MOVF   64,W
04AC:  MOVWF  6D
04AD:  CLRF   6C
04AE:  BCF    03.0
04AF:  RRF    6F,F
04B0:  RRF    6E,F
04B1:  RRF    6D,F
04B2:  RRF    6C,F
04B3:  DECFSZ 69,F
04B4:  GOTO   4AD
04B5:  BTFSS  6A.7
04B6:  GOTO   4BA
04B7:  BSF    6B.1
04B8:  GOTO   55B
04B9:  BCF    6B.1
04BA:  BCF    69.0
04BB:  BSF    6B.5
04BC:  MOVLW  68
04BD:  MOVWF  04
04BE:  BCF    03.7
04BF:  GOTO   570
04C0:  BCF    6B.5
04C1:  BTFSC  6A.7
04C2:  GOTO   4CD
04C3:  BTFSS  69.0
04C4:  GOTO   4D8
04C5:  RRF    6F,F
04C6:  RRF    6E,F
04C7:  RRF    6D,F
04C8:  RRF    6C,F
04C9:  INCF   77,F
04CA:  BTFSC  03.2
04CB:  GOTO   556
04CC:  GOTO   4D8
04CD:  BTFSC  6F.7
04CE:  GOTO   4DB
04CF:  BCF    03.0
04D0:  RLF    6C,F
04D1:  RLF    6D,F
04D2:  RLF    6E,F
04D3:  RLF    6F,F
04D4:  DECF   77,F
04D5:  BTFSC  03.2
04D6:  GOTO   556
04D7:  GOTO   4CD
04D8:  BSF    6B.7
04D9:  GOTO   503
04DA:  BCF    6B.7
04DB:  MOVF   66,W
04DC:  MOVWF  6A
04DD:  BTFSS  6A.7
04DE:  GOTO   4E1
04DF:  BSF    6F.7
04E0:  GOTO   54F
04E1:  BCF    6F.7
04E2:  GOTO   54F
04E3:  MOVF   66,W
04E4:  MOVWF  6F
04E5:  BSF    6F.7
04E6:  MOVF   67,W
04E7:  MOVWF  6E
04E8:  MOVF   68,W
04E9:  MOVWF  6D
04EA:  BTFSS  6A.7
04EB:  GOTO   4F0
04EC:  BCF    6F.7
04ED:  BSF    6B.2
04EE:  GOTO   55B
04EF:  BCF    6B.2
04F0:  CLRF   6C
04F1:  BCF    69.0
04F2:  MOVLW  64
04F3:  MOVWF  04
04F4:  BCF    03.7
04F5:  GOTO   570
04F6:  BTFSC  6A.7
04F7:  GOTO   519
04F8:  MOVF   62,W
04F9:  MOVWF  6A
04FA:  BTFSS  69.0
04FB:  GOTO   503
04FC:  RRF    6F,F
04FD:  RRF    6E,F
04FE:  RRF    6D,F
04FF:  RRF    6C,F
0500:  INCF   77,F
0501:  BTFSC  03.2
0502:  GOTO   556
0503:  BTFSS  6C.7
0504:  GOTO   514
0505:  INCF   6D,F
0506:  BTFSS  03.2
0507:  GOTO   514
0508:  INCF   6E,F
0509:  BTFSS  03.2
050A:  GOTO   514
050B:  INCF   6F,F
050C:  BTFSS  03.2
050D:  GOTO   514
050E:  RRF    6F,F
050F:  RRF    6E,F
0510:  RRF    6D,F
0511:  INCF   77,F
0512:  BTFSC  03.2
0513:  GOTO   556
0514:  BTFSC  6B.6
0515:  GOTO   498
0516:  BTFSC  6B.7
0517:  GOTO   4DA
0518:  GOTO   538
0519:  MOVLW  80
051A:  XORWF  6F,F
051B:  BTFSS  6F.7
051C:  GOTO   521
051D:  GOTO   55B
051E:  MOVF   66,W
051F:  MOVWF  6A
0520:  GOTO   52E
0521:  MOVF   62,W
0522:  MOVWF  6A
0523:  MOVF   6F,F
0524:  BTFSS  03.2
0525:  GOTO   52E
0526:  MOVF   6E,F
0527:  BTFSS  03.2
0528:  GOTO   52E
0529:  MOVF   6D,F
052A:  BTFSS  03.2
052B:  GOTO   52E
052C:  CLRF   77
052D:  GOTO   54F
052E:  BTFSC  6F.7
052F:  GOTO   538
0530:  BCF    03.0
0531:  RLF    6C,F
0532:  RLF    6D,F
0533:  RLF    6E,F
0534:  RLF    6F,F
0535:  DECFSZ 77,F
0536:  GOTO   52E
0537:  GOTO   556
0538:  BTFSS  6A.7
0539:  GOTO   53C
053A:  BSF    6F.7
053B:  GOTO   54F
053C:  BCF    6F.7
053D:  GOTO   54F
053E:  MOVF   65,W
053F:  MOVWF  77
0540:  MOVF   66,W
0541:  MOVWF  6F
0542:  MOVF   67,W
0543:  MOVWF  6E
0544:  MOVF   68,W
0545:  MOVWF  6D
0546:  GOTO   54F
0547:  MOVF   61,W
0548:  MOVWF  77
0549:  MOVF   62,W
054A:  MOVWF  6F
054B:  MOVF   63,W
054C:  MOVWF  6E
054D:  MOVF   64,W
054E:  MOVWF  6D
054F:  MOVF   6F,W
0550:  MOVWF  78
0551:  MOVF   6E,W
0552:  MOVWF  79
0553:  MOVF   6D,W
0554:  MOVWF  7A
0555:  GOTO   58E
0556:  CLRF   77
0557:  CLRF   78
0558:  CLRF   79
0559:  CLRF   7A
055A:  GOTO   58E
055B:  CLRF   6C
055C:  COMF   6D,F
055D:  COMF   6E,F
055E:  COMF   6F,F
055F:  COMF   6C,F
0560:  INCF   6C,F
0561:  BTFSS  03.2
0562:  GOTO   569
0563:  INCF   6D,F
0564:  BTFSS  03.2
0565:  GOTO   569
0566:  INCF   6E,F
0567:  BTFSC  03.2
0568:  INCF   6F,F
0569:  BTFSC  6B.0
056A:  GOTO   477
056B:  BTFSC  6B.1
056C:  GOTO   4B9
056D:  BTFSC  6B.2
056E:  GOTO   4EF
056F:  GOTO   51E
0570:  MOVF   00,W
0571:  ADDWF  6D,F
0572:  BTFSS  03.0
0573:  GOTO   57A
0574:  INCF   6E,F
0575:  BTFSS  03.2
0576:  GOTO   57A
0577:  INCF   6F,F
0578:  BTFSC  03.2
0579:  BSF    69.0
057A:  DECF   04,F
057B:  MOVF   00,W
057C:  ADDWF  6E,F
057D:  BTFSS  03.0
057E:  GOTO   582
057F:  INCF   6F,F
0580:  BTFSC  03.2
0581:  BSF    69.0
0582:  DECF   04,F
0583:  MOVF   00,W
0584:  BTFSS  00.7
0585:  XORLW  80
0586:  ADDWF  6F,F
0587:  BTFSC  03.0
0588:  BSF    69.0
0589:  BTFSC  6B.4
058A:  GOTO   47E
058B:  BTFSC  6B.5
058C:  GOTO   4C0
058D:  GOTO   4F6
058E:  RETURN
*
0743:  MOVF   4C,W
0744:  SUBLW  B6
0745:  MOVWF  4C
0746:  CLRF   7A
0747:  MOVF   4D,W
0748:  MOVWF  50
0749:  BSF    4D.7
074A:  BCF    03.0
074B:  RRF    4D,F
074C:  RRF    4E,F
074D:  RRF    4F,F
074E:  RRF    7A,F
074F:  RRF    79,F
0750:  RRF    78,F
0751:  RRF    77,F
0752:  DECFSZ 4C,F
0753:  GOTO   74A
0754:  BTFSS  50.7
0755:  GOTO   761
0756:  COMF   77,F
0757:  COMF   78,F
0758:  COMF   79,F
0759:  COMF   7A,F
075A:  INCF   77,F
075B:  BTFSC  03.2
075C:  INCF   78,F
075D:  BTFSC  03.2
075E:  INCF   79,F
075F:  BTFSC  03.2
0760:  INCF   7A,F
0761:  RETURN
0762:  BTFSC  03.1
0763:  GOTO   767
0764:  MOVLW  54
0765:  MOVWF  04
0766:  BCF    03.7
0767:  CLRF   77
0768:  CLRF   78
0769:  CLRF   79
076A:  CLRF   7A
076B:  CLRF   54
076C:  CLRF   55
076D:  CLRF   56
076E:  CLRF   57
076F:  MOVF   53,W
0770:  IORWF  52,W
0771:  IORWF  51,W
0772:  IORWF  50,W
0773:  BTFSC  03.2
0774:  GOTO   7A5
0775:  MOVLW  20
0776:  MOVWF  58
0777:  BCF    03.0
0778:  RLF    4C,F
0779:  RLF    4D,F
077A:  RLF    4E,F
077B:  RLF    4F,F
077C:  RLF    54,F
077D:  RLF    55,F
077E:  RLF    56,F
077F:  RLF    57,F
0780:  MOVF   53,W
0781:  SUBWF  57,W
0782:  BTFSS  03.2
0783:  GOTO   78E
0784:  MOVF   52,W
0785:  SUBWF  56,W
0786:  BTFSS  03.2
0787:  GOTO   78E
0788:  MOVF   51,W
0789:  SUBWF  55,W
078A:  BTFSS  03.2
078B:  GOTO   78E
078C:  MOVF   50,W
078D:  SUBWF  54,W
078E:  BTFSS  03.0
078F:  GOTO   79F
0790:  MOVF   50,W
0791:  SUBWF  54,F
0792:  MOVF   51,W
0793:  BTFSS  03.0
0794:  INCFSZ 51,W
0795:  SUBWF  55,F
0796:  MOVF   52,W
0797:  BTFSS  03.0
0798:  INCFSZ 52,W
0799:  SUBWF  56,F
079A:  MOVF   53,W
079B:  BTFSS  03.0
079C:  INCFSZ 53,W
079D:  SUBWF  57,F
079E:  BSF    03.0
079F:  RLF    77,F
07A0:  RLF    78,F
07A1:  RLF    79,F
07A2:  RLF    7A,F
07A3:  DECFSZ 58,F
07A4:  GOTO   777
07A5:  MOVF   54,W
07A6:  MOVWF  00
07A7:  INCF   04,F
07A8:  MOVF   55,W
07A9:  MOVWF  00
07AA:  INCF   04,F
07AB:  MOVF   56,W
07AC:  MOVWF  00
07AD:  INCF   04,F
07AE:  MOVF   57,W
07AF:  MOVWF  00
07B0:  RETURN
07B1:  MOVF   40,W
07B2:  MOVWF  47
07B3:  MOVF   44,W
07B4:  XORWF  47,F
07B5:  BTFSS  47.7
07B6:  GOTO   7BC
07B7:  BCF    03.2
07B8:  BCF    03.0
07B9:  BTFSC  40.7
07BA:  BSF    03.0
07BB:  GOTO   7EF
07BC:  MOVF   40,W
07BD:  MOVWF  47
07BE:  MOVF   43,W
07BF:  MOVWF  48
07C0:  MOVF   3F,W
07C1:  SUBWF  48,F
07C2:  BTFSC  03.2
07C3:  GOTO   7CA
07C4:  BTFSS  47.7
07C5:  GOTO   7EF
07C6:  MOVF   03,W
07C7:  XORLW  01
07C8:  MOVWF  03
07C9:  GOTO   7EF
07CA:  MOVF   44,W
07CB:  MOVWF  48
07CC:  MOVF   40,W
07CD:  SUBWF  48,F
07CE:  BTFSC  03.2
07CF:  GOTO   7D6
07D0:  BTFSS  47.7
07D1:  GOTO   7EF
07D2:  MOVF   03,W
07D3:  XORLW  01
07D4:  MOVWF  03
07D5:  GOTO   7EF
07D6:  MOVF   45,W
07D7:  MOVWF  48
07D8:  MOVF   41,W
07D9:  SUBWF  48,F
07DA:  BTFSC  03.2
07DB:  GOTO   7E2
07DC:  BTFSS  47.7
07DD:  GOTO   7EF
07DE:  MOVF   03,W
07DF:  XORLW  01
07E0:  MOVWF  03
07E1:  GOTO   7EF
07E2:  MOVF   46,W
07E3:  MOVWF  48
07E4:  MOVF   42,W
07E5:  SUBWF  48,F
07E6:  BTFSC  03.2
07E7:  GOTO   7EE
07E8:  BTFSS  47.7
07E9:  GOTO   7EF
07EA:  MOVF   03,W
07EB:  XORLW  01
07EC:  MOVWF  03
07ED:  GOTO   7EF
07EE:  BCF    03.0
07EF:  RETURN
*
0800:  MOVF   04,W
0801:  MOVWF  44
0802:  MOVF   43,W
0803:  MOVWF  46
0804:  BTFSC  03.2
0805:  GOTO   021
0806:  MOVF   42,W
0807:  MOVWF  60
0808:  MOVF   41,W
0809:  MOVWF  5F
080A:  MOVF   40,W
080B:  MOVWF  5E
080C:  MOVF   3F,W
080D:  MOVWF  5D
080E:  CLRF   64
080F:  CLRF   63
0810:  MOVLW  20
0811:  MOVWF  62
0812:  MOVLW  82
0813:  MOVWF  61
0814:  BCF    0A.3
0815:  CALL   2F2
0816:  BSF    0A.3
0817:  MOVF   7A,W
0818:  MOVWF  42
0819:  MOVF   79,W
081A:  MOVWF  41
081B:  MOVF   78,W
081C:  MOVWF  40
081D:  MOVF   77,W
081E:  MOVWF  3F
081F:  DECFSZ 46,F
0820:  GOTO   006
0821:  MOVF   42,W
0822:  MOVWF  4F
0823:  MOVF   41,W
0824:  MOVWF  4E
0825:  MOVF   40,W
0826:  MOVWF  4D
0827:  MOVF   3F,W
0828:  MOVWF  4C
0829:  BCF    0A.3
082A:  CALL   743
082B:  BSF    0A.3
082C:  MOVF   7A,W
082D:  MOVWF  42
082E:  MOVF   79,W
082F:  MOVWF  41
0830:  MOVF   78,W
0831:  MOVWF  40
0832:  MOVF   77,W
0833:  MOVWF  3F
0834:  BTFSS  42.7
0835:  GOTO   043
0836:  DECF   44,F
0837:  BSF    44.5
0838:  COMF   3F,F
0839:  COMF   40,F
083A:  COMF   41,F
083B:  COMF   42,F
083C:  INCF   3F,F
083D:  BTFSC  03.2
083E:  INCF   40,F
083F:  BTFSC  03.2
0840:  INCF   41,F
0841:  BTFSC  03.2
0842:  INCF   42,F
0843:  MOVLW  3B
0844:  MOVWF  4B
0845:  MOVLW  9A
0846:  MOVWF  4A
0847:  MOVLW  CA
0848:  MOVWF  49
0849:  CLRF   48
084A:  MOVLW  0A
084B:  MOVWF  46
084C:  MOVF   43,W
084D:  BTFSC  03.2
084E:  INCF   44,F
084F:  BSF    03.1
0850:  MOVLW  3F
0851:  MOVWF  04
0852:  BCF    03.7
0853:  MOVF   42,W
0854:  MOVWF  4F
0855:  MOVF   41,W
0856:  MOVWF  4E
0857:  MOVF   40,W
0858:  MOVWF  4D
0859:  MOVF   3F,W
085A:  MOVWF  4C
085B:  MOVF   4B,W
085C:  MOVWF  53
085D:  MOVF   4A,W
085E:  MOVWF  52
085F:  MOVF   49,W
0860:  MOVWF  51
0861:  MOVF   48,W
0862:  MOVWF  50
0863:  BCF    0A.3
0864:  CALL   762
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVF   77,F
0868:  BTFSS  03.2
0869:  GOTO   07D
086A:  INCF   43,W
086B:  SUBWF  46,W
086C:  BTFSC  03.2
086D:  GOTO   07D
086E:  MOVF   44,W
086F:  BTFSC  03.2
0870:  GOTO   07F
0871:  ANDLW  0F
0872:  SUBWF  46,W
0873:  BTFSC  03.2
0874:  GOTO   077
0875:  BTFSC  03.0
0876:  GOTO   0B7
0877:  BTFSC  44.7
0878:  GOTO   0B7
0879:  BTFSC  44.6
087A:  GOTO   07F
087B:  MOVLW  20
087C:  GOTO   0B1
087D:  MOVLW  20
087E:  ANDWF  44,F
087F:  BTFSS  44.5
0880:  GOTO   08F
0881:  BCF    44.5
0882:  MOVF   43,W
0883:  BTFSS  03.2
0884:  DECF   44,F
0885:  MOVF   77,W
0886:  MOVWF  44
0887:  MOVLW  2D
0888:  MOVWF  4C
0889:  BCF    0A.3
088A:  CALL   1BF
088B:  BSF    0A.3
088C:  MOVF   44,W
088D:  MOVWF  77
088E:  CLRF   44
088F:  MOVF   43,W
0890:  SUBWF  46,W
0891:  BTFSS  03.2
0892:  GOTO   09F
0893:  MOVF   77,W
0894:  MOVWF  44
0895:  MOVLW  2E
0896:  MOVWF  4C
0897:  BCF    0A.3
0898:  CALL   1BF
0899:  BSF    0A.3
089A:  MOVF   44,W
089B:  MOVWF  77
089C:  MOVLW  20
089D:  ANDWF  44,F
089E:  MOVLW  00
089F:  MOVLW  30
08A0:  BTFSS  44.5
08A1:  GOTO   0B1
08A2:  BCF    44.5
08A3:  MOVF   43,W
08A4:  BTFSS  03.2
08A5:  DECF   44,F
08A6:  MOVF   77,W
08A7:  MOVWF  44
08A8:  MOVLW  2D
08A9:  MOVWF  4C
08AA:  BCF    0A.3
08AB:  CALL   1BF
08AC:  BSF    0A.3
08AD:  MOVF   44,W
08AE:  MOVWF  77
08AF:  CLRF   44
08B0:  MOVLW  30
08B1:  ADDWF  77,F
08B2:  MOVF   77,W
08B3:  MOVWF  4C
08B4:  BCF    0A.3
08B5:  CALL   1BF
08B6:  BSF    0A.3
08B7:  BCF    03.1
08B8:  MOVF   4B,W
08B9:  MOVWF  4F
08BA:  MOVF   4A,W
08BB:  MOVWF  4E
08BC:  MOVF   49,W
08BD:  MOVWF  4D
08BE:  MOVF   48,W
08BF:  MOVWF  4C
08C0:  CLRF   53
08C1:  CLRF   52
08C2:  CLRF   51
08C3:  MOVLW  0A
08C4:  MOVWF  50
08C5:  BCF    0A.3
08C6:  CALL   762
08C7:  BSF    0A.3
08C8:  MOVF   7A,W
08C9:  MOVWF  4B
08CA:  MOVF   79,W
08CB:  MOVWF  4A
08CC:  MOVF   78,W
08CD:  MOVWF  49
08CE:  MOVF   77,W
08CF:  MOVWF  48
08D0:  DECFSZ 46,F
08D1:  GOTO   04F
08D2:  RETURN
08D3:  MOVF   0B,W
08D4:  MOVWF  40
08D5:  BCF    0B.7
08D6:  BSF    03.5
08D7:  BSF    03.6
08D8:  BSF    0C.7
08D9:  BSF    0C.0
08DA:  NOP
08DB:  NOP
08DC:  BCF    03.5
08DD:  BCF    03.6
08DE:  BTFSC  40.7
08DF:  BSF    0B.7
08E0:  BTFSC  03.0
08E1:  GOTO   10B
08E2:  BSF    03.6
08E3:  MOVF   0C,W
08E4:  ANDLW  7F
08E5:  BCF    03.6
08E6:  MOVWF  40
08E7:  BSF    03.6
08E8:  MOVF   0D,W
08E9:  BCF    03.6
08EA:  MOVWF  41
08EB:  BSF    03.6
08EC:  MOVF   0F,W
08ED:  BCF    03.6
08EE:  MOVWF  42
08EF:  MOVF   40,W
08F0:  BTFSS  0C.4
08F1:  GOTO   0F0
08F2:  MOVWF  19
08F3:  MOVF   41,W
08F4:  BSF    03.6
08F5:  MOVWF  0D
08F6:  BCF    03.6
08F7:  MOVF   42,W
08F8:  BSF    03.6
08F9:  MOVWF  0F
08FA:  BCF    03.6
08FB:  MOVF   0B,W
08FC:  MOVWF  43
08FD:  BCF    0B.7
08FE:  BSF    03.5
08FF:  BSF    03.6
0900:  BSF    0C.7
0901:  BSF    0C.0
0902:  NOP
0903:  NOP
0904:  BCF    03.5
0905:  BCF    03.6
0906:  BTFSC  43.7
0907:  BSF    0B.7
0908:  DECFSZ 3F,F
0909:  GOTO   10B
090A:  GOTO   12B
090B:  BSF    03.6
090C:  RLF    0C,W
090D:  RLF    0E,W
090E:  ANDLW  7F
090F:  BCF    03.6
0910:  MOVWF  40
0911:  BSF    03.6
0912:  MOVF   0D,W
0913:  BCF    03.6
0914:  MOVWF  41
0915:  BSF    03.6
0916:  MOVF   0F,W
0917:  BCF    03.6
0918:  MOVWF  42
0919:  MOVF   40,W
091A:  BTFSS  0C.4
091B:  GOTO   11A
091C:  MOVWF  19
091D:  MOVF   41,W
091E:  BSF    03.6
091F:  MOVWF  0D
0920:  BCF    03.6
0921:  MOVF   42,W
0922:  BSF    03.6
0923:  MOVWF  0F
0924:  INCF   0D,F
0925:  BTFSC  03.2
0926:  INCF   0F,F
0927:  BCF    03.0
0928:  BCF    03.6
0929:  DECFSZ 3F,F
092A:  GOTO   0D3
092B:  RETURN
092C:  MOVF   04,W
092D:  MOVWF  44
092E:  MOVF   43,W
092F:  MOVWF  46
0930:  BTFSC  03.2
0931:  GOTO   14D
0932:  MOVF   42,W
0933:  MOVWF  60
0934:  MOVF   41,W
0935:  MOVWF  5F
0936:  MOVF   40,W
0937:  MOVWF  5E
0938:  MOVF   3F,W
0939:  MOVWF  5D
093A:  CLRF   64
093B:  CLRF   63
093C:  MOVLW  20
093D:  MOVWF  62
093E:  MOVLW  82
093F:  MOVWF  61
0940:  BCF    0A.3
0941:  CALL   2F2
0942:  BSF    0A.3
0943:  MOVF   7A,W
0944:  MOVWF  42
0945:  MOVF   79,W
0946:  MOVWF  41
0947:  MOVF   78,W
0948:  MOVWF  40
0949:  MOVF   77,W
094A:  MOVWF  3F
094B:  DECFSZ 46,F
094C:  GOTO   132
094D:  MOVF   42,W
094E:  MOVWF  4F
094F:  MOVF   41,W
0950:  MOVWF  4E
0951:  MOVF   40,W
0952:  MOVWF  4D
0953:  MOVF   3F,W
0954:  MOVWF  4C
0955:  BCF    0A.3
0956:  CALL   743
0957:  BSF    0A.3
0958:  MOVF   7A,W
0959:  MOVWF  42
095A:  MOVF   79,W
095B:  MOVWF  41
095C:  MOVF   78,W
095D:  MOVWF  40
095E:  MOVF   77,W
095F:  MOVWF  3F
0960:  BTFSS  42.7
0961:  GOTO   16F
0962:  DECF   44,F
0963:  BSF    44.5
0964:  COMF   3F,F
0965:  COMF   40,F
0966:  COMF   41,F
0967:  COMF   42,F
0968:  INCF   3F,F
0969:  BTFSC  03.2
096A:  INCF   40,F
096B:  BTFSC  03.2
096C:  INCF   41,F
096D:  BTFSC  03.2
096E:  INCF   42,F
096F:  MOVLW  3B
0970:  MOVWF  4B
0971:  MOVLW  9A
0972:  MOVWF  4A
0973:  MOVLW  CA
0974:  MOVWF  49
0975:  CLRF   48
0976:  MOVLW  0A
0977:  MOVWF  46
0978:  MOVF   43,W
0979:  BTFSC  03.2
097A:  INCF   44,F
097B:  BSF    03.1
097C:  MOVLW  3F
097D:  MOVWF  04
097E:  BCF    03.7
097F:  MOVF   42,W
0980:  MOVWF  4F
0981:  MOVF   41,W
0982:  MOVWF  4E
0983:  MOVF   40,W
0984:  MOVWF  4D
0985:  MOVF   3F,W
0986:  MOVWF  4C
0987:  MOVF   4B,W
0988:  MOVWF  53
0989:  MOVF   4A,W
098A:  MOVWF  52
098B:  MOVF   49,W
098C:  MOVWF  51
098D:  MOVF   48,W
098E:  MOVWF  50
098F:  BCF    0A.3
0990:  CALL   762
0991:  BSF    0A.3
0992:  MOVF   78,W
0993:  MOVF   77,F
0994:  BTFSS  03.2
0995:  GOTO   1A9
0996:  INCF   43,W
0997:  SUBWF  46,W
0998:  BTFSC  03.2
0999:  GOTO   1A9
099A:  MOVF   44,W
099B:  BTFSC  03.2
099C:  GOTO   1AB
099D:  ANDLW  0F
099E:  SUBWF  46,W
099F:  BTFSC  03.2
09A0:  GOTO   1A3
09A1:  BTFSC  03.0
09A2:  GOTO   1DF
09A3:  BTFSC  44.7
09A4:  GOTO   1DF
09A5:  BTFSC  44.6
09A6:  GOTO   1AB
09A7:  MOVLW  20
09A8:  GOTO   1DA
09A9:  MOVLW  20
09AA:  ANDWF  44,F
09AB:  BTFSS  44.5
09AC:  GOTO   1BA
09AD:  BCF    44.5
09AE:  MOVF   43,W
09AF:  BTFSS  03.2
09B0:  DECF   44,F
09B1:  MOVF   77,W
09B2:  MOVWF  44
09B3:  MOVLW  2D
09B4:  BTFSS  0C.4
09B5:  GOTO   1B4
09B6:  MOVWF  19
09B7:  MOVF   44,W
09B8:  MOVWF  77
09B9:  CLRF   44
09BA:  MOVF   43,W
09BB:  SUBWF  46,W
09BC:  BTFSS  03.2
09BD:  GOTO   1C9
09BE:  MOVF   77,W
09BF:  MOVWF  44
09C0:  MOVLW  2E
09C1:  BTFSS  0C.4
09C2:  GOTO   1C1
09C3:  MOVWF  19
09C4:  MOVF   44,W
09C5:  MOVWF  77
09C6:  MOVLW  20
09C7:  ANDWF  44,F
09C8:  MOVLW  00
09C9:  MOVLW  30
09CA:  BTFSS  44.5
09CB:  GOTO   1DA
09CC:  BCF    44.5
09CD:  MOVF   43,W
09CE:  BTFSS  03.2
09CF:  DECF   44,F
09D0:  MOVF   77,W
09D1:  MOVWF  44
09D2:  MOVLW  2D
09D3:  BTFSS  0C.4
09D4:  GOTO   1D3
09D5:  MOVWF  19
09D6:  MOVF   44,W
09D7:  MOVWF  77
09D8:  CLRF   44
09D9:  MOVLW  30
09DA:  ADDWF  77,F
09DB:  MOVF   77,W
09DC:  BTFSS  0C.4
09DD:  GOTO   1DC
09DE:  MOVWF  19
09DF:  BCF    03.1
09E0:  MOVF   4B,W
09E1:  MOVWF  4F
09E2:  MOVF   4A,W
09E3:  MOVWF  4E
09E4:  MOVF   49,W
09E5:  MOVWF  4D
09E6:  MOVF   48,W
09E7:  MOVWF  4C
09E8:  CLRF   53
09E9:  CLRF   52
09EA:  CLRF   51
09EB:  MOVLW  0A
09EC:  MOVWF  50
09ED:  BCF    0A.3
09EE:  CALL   762
09EF:  BSF    0A.3
09F0:  MOVF   7A,W
09F1:  MOVWF  4B
09F2:  MOVF   79,W
09F3:  MOVWF  4A
09F4:  MOVF   78,W
09F5:  MOVWF  49
09F6:  MOVF   77,W
09F7:  MOVWF  48
09F8:  DECFSZ 46,F
09F9:  GOTO   17B
09FA:  RETURN
09FB:  MOVF   78,W
09FC:  MOVF   3F,W
09FD:  MOVWF  52
09FE:  MOVLW  64
09FF:  MOVWF  53
0A00:  BCF    0A.3
0A01:  CALL   279
0A02:  BSF    0A.3
0A03:  MOVF   77,W
0A04:  MOVWF  3F
0A05:  MOVF   78,W
0A06:  MOVLW  30
0A07:  BTFSS  03.2
0A08:  GOTO   210
0A09:  BTFSS  40.1
0A0A:  GOTO   218
0A0B:  BTFSC  40.3
0A0C:  GOTO   218
0A0D:  BTFSC  40.4
0A0E:  MOVLW  20
0A0F:  GOTO   213
0A10:  BCF    40.3
0A11:  BCF    40.4
0A12:  BSF    40.0
0A13:  ADDWF  78,F
0A14:  MOVF   78,W
0A15:  BTFSS  0C.4
0A16:  GOTO   215
0A17:  MOVWF  19
0A18:  MOVF   3F,W
0A19:  MOVWF  52
0A1A:  MOVLW  0A
0A1B:  MOVWF  53
0A1C:  BCF    0A.3
0A1D:  CALL   279
0A1E:  BSF    0A.3
0A1F:  MOVF   77,W
0A20:  MOVWF  3F
0A21:  MOVF   78,W
0A22:  MOVLW  30
0A23:  BTFSS  03.2
0A24:  GOTO   22B
0A25:  BTFSC  40.3
0A26:  GOTO   230
0A27:  BTFSS  40.0
0A28:  GOTO   230
0A29:  BTFSC  40.4
0A2A:  MOVLW  20
0A2B:  ADDWF  78,F
0A2C:  MOVF   78,W
0A2D:  BTFSS  0C.4
0A2E:  GOTO   22D
0A2F:  MOVWF  19
0A30:  MOVLW  30
0A31:  ADDWF  3F,F
0A32:  MOVF   3F,W
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
0A36:  RETURN
0A37:  MOVF   0B,W
0A38:  MOVWF  3F
0A39:  BCF    0B.7
0A3A:  BSF    03.5
0A3B:  BSF    03.6
0A3C:  BSF    0C.7
0A3D:  BSF    0C.0
0A3E:  NOP
0A3F:  NOP
0A40:  BCF    03.5
0A41:  BCF    03.6
0A42:  BTFSC  3F.7
0A43:  BSF    0B.7
0A44:  BSF    03.6
0A45:  MOVF   0C,W
0A46:  ANDLW  7F
0A47:  BTFSC  03.2
0A48:  GOTO   28D
0A49:  BCF    03.6
0A4A:  MOVWF  3F
0A4B:  BSF    03.6
0A4C:  MOVF   0D,W
0A4D:  BCF    03.6
0A4E:  MOVWF  40
0A4F:  BSF    03.6
0A50:  MOVF   0F,W
0A51:  BCF    03.6
0A52:  MOVWF  41
0A53:  MOVF   3F,W
0A54:  BTFSS  0C.4
0A55:  GOTO   254
0A56:  MOVWF  19
0A57:  MOVF   40,W
0A58:  BSF    03.6
0A59:  MOVWF  0D
0A5A:  BCF    03.6
0A5B:  MOVF   41,W
0A5C:  BSF    03.6
0A5D:  MOVWF  0F
0A5E:  BCF    03.6
0A5F:  MOVF   0B,W
0A60:  MOVWF  42
0A61:  BCF    0B.7
0A62:  BSF    03.5
0A63:  BSF    03.6
0A64:  BSF    0C.7
0A65:  BSF    0C.0
0A66:  NOP
0A67:  NOP
0A68:  BCF    03.5
0A69:  BCF    03.6
0A6A:  BTFSC  42.7
0A6B:  BSF    0B.7
0A6C:  BSF    03.6
0A6D:  RLF    0C,W
0A6E:  RLF    0E,W
0A6F:  ANDLW  7F
0A70:  BTFSC  03.2
0A71:  GOTO   28D
0A72:  BCF    03.6
0A73:  MOVWF  3F
0A74:  BSF    03.6
0A75:  MOVF   0D,W
0A76:  BCF    03.6
0A77:  MOVWF  40
0A78:  BSF    03.6
0A79:  MOVF   0F,W
0A7A:  BCF    03.6
0A7B:  MOVWF  41
0A7C:  MOVF   3F,W
0A7D:  BTFSS  0C.4
0A7E:  GOTO   27D
0A7F:  MOVWF  19
0A80:  MOVF   40,W
0A81:  BSF    03.6
0A82:  MOVWF  0D
0A83:  BCF    03.6
0A84:  MOVF   41,W
0A85:  BSF    03.6
0A86:  MOVWF  0F
0A87:  INCF   0D,F
0A88:  BTFSC  03.2
0A89:  INCF   0F,F
0A8A:  BCF    03.6
0A8B:  GOTO   237
0A8C:  BSF    03.6
0A8D:  BCF    03.6
0A8E:  RETURN
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, PROTECT, NOLVP, MCLR, NOLVP, NOBROWNOUT 
.................... #use delay(INTERNAL=4000000) 
*
0108:  MOVLW  4D
0109:  MOVWF  04
010A:  BCF    03.7
010B:  MOVF   00,W
010C:  BTFSC  03.2
010D:  GOTO   11C
010E:  MOVLW  01
010F:  MOVWF  78
0110:  CLRF   77
0111:  DECFSZ 77,F
0112:  GOTO   111
0113:  DECFSZ 78,F
0114:  GOTO   110
0115:  MOVLW  4A
0116:  MOVWF  77
0117:  DECFSZ 77,F
0118:  GOTO   117
0119:  GOTO   11A
011A:  DECFSZ 00,F
011B:  GOTO   10E
011C:  RETURN
.................... // se inicializa el puerto serie en el microcontrolador 
.................... #use RS232(baud = 9600, xmit = PIN_C6, rcv = PIN_C7, timeout = 100)  
*
0241:  MOVLW  01
0242:  MOVWF  40
0243:  MOVLW  40
0244:  MOVWF  3F
0245:  MOVLW  67
0246:  MOVWF  77
0247:  DECFSZ 77,F
0248:  GOTO   247
0249:  GOTO   24A
024A:  DECFSZ 3F,F
024B:  GOTO   251
024C:  DECFSZ 40,F
024D:  GOTO   251
024E:  CLRF   20
024F:  CLRF   78
0250:  GOTO   25B
0251:  BTFSS  0C.5
0252:  GOTO   245
0253:  MOVF   18,W
0254:  MOVWF  20
0255:  MOVF   1A,W
0256:  MOVWF  78
0257:  BTFSS  20.1
0258:  GOTO   25B
0259:  BCF    18.4
025A:  BSF    18.4
025B:  RETURN
.................... //argumentos PS(ancho de banda (Tx bits/s), pin Tx, pin Rx, tiempo de respuesta) 
....................  //Sensores 
.................... #define DHT11_PIN PIN_A0 
.................... #define spuerta PIN_A1 
.................... // se define el puerto D completo para la conexion al LCD 
.................... #define LCD_DATA_PORT getenv("SFR:PORTD") 
.................... // se define el uso de la biblioteca para manipular LCD 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0135:  MOVLW  0F
0136:  BSF    03.5
0137:  ANDWF  08,W
0138:  IORLW  F0
0139:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
013A:  BCF    03.5
013B:  BSF    08.2
....................    delay_cycles(1); 
013C:  NOP
....................    lcd_output_enable(1); 
013D:  BSF    08.0
....................    delay_cycles(1); 
013E:  NOP
....................    high = lcd_read_nibble(); 
013F:  CALL   129
0140:  MOVF   78,W
0141:  MOVWF  54
....................        
....................    lcd_output_enable(0); 
0142:  BCF    08.0
....................    delay_cycles(1); 
0143:  NOP
....................    lcd_output_enable(1); 
0144:  BSF    08.0
....................    delay_us(1); 
0145:  NOP
....................    low = lcd_read_nibble(); 
0146:  CALL   129
0147:  MOVF   78,W
0148:  MOVWF  53
....................        
....................    lcd_output_enable(0); 
0149:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
014A:  MOVLW  0F
014B:  BSF    03.5
014C:  ANDWF  08,W
014D:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
014E:  BCF    03.5
014F:  SWAPF  54,W
0150:  MOVWF  77
0151:  MOVLW  F0
0152:  ANDWF  77,F
0153:  MOVF   77,W
0154:  IORWF  53,W
0155:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0129:  MOVF   08,W
012A:  MOVWF  77
012B:  SWAPF  08,W
012C:  ANDLW  0F
012D:  MOVWF  78
....................   #endif 
012E:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
011D:  SWAPF  54,W
011E:  ANDLW  F0
011F:  MOVWF  77
0120:  MOVLW  0F
0121:  ANDWF  08,W
0122:  IORWF  77,W
0123:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0124:  NOP
....................    lcd_output_enable(1); 
0125:  BSF    08.0
....................    delay_us(2); 
0126:  GOTO   127
....................    lcd_output_enable(0); 
0127:  BCF    08.0
0128:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
012F:  BSF    03.5
0130:  BCF    08.0
....................    lcd_rs_tris(); 
0131:  BCF    08.1
....................    lcd_rw_tris(); 
0132:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0133:  BCF    03.5
0134:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0156:  MOVF   78,W
0157:  MOVWF  53
0158:  BTFSC  53.7
0159:  GOTO   135
....................    lcd_output_rs(address); 
015A:  BTFSS  51.0
015B:  BCF    08.1
015C:  BTFSC  51.0
015D:  BSF    08.1
....................    delay_cycles(1); 
015E:  NOP
....................    lcd_output_rw(0); 
015F:  BCF    08.2
....................    delay_cycles(1); 
0160:  NOP
....................    lcd_output_enable(0); 
0161:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0162:  SWAPF  52,W
0163:  MOVWF  53
0164:  MOVLW  0F
0165:  ANDWF  53,F
0166:  MOVF   53,W
0167:  MOVWF  54
0168:  CALL   11D
....................    lcd_send_nibble(n & 0xf); 
0169:  MOVF   52,W
016A:  ANDLW  0F
016B:  MOVWF  53
016C:  MOVWF  54
016D:  CALL   11D
016E:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
016F:  MOVLW  28
0170:  MOVWF  40
0171:  MOVLW  0C
0172:  MOVWF  41
0173:  MOVLW  01
0174:  MOVWF  42
0175:  MOVLW  06
0176:  MOVWF  43
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0177:  BCF    08.0
....................    lcd_output_rs(0); 
0178:  BCF    08.1
....................    lcd_output_rw(0); 
0179:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
017A:  MOVLW  0F
017B:  BSF    03.5
017C:  ANDWF  08,W
017D:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
017E:  BCF    08.0
....................    lcd_rs_tris(); 
017F:  BCF    08.1
....................    lcd_rw_tris(); 
0180:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
0181:  MOVLW  0F
0182:  BCF    03.5
0183:  MOVWF  4D
0184:  CALL   108
....................    for(i=1;i<=3;++i) 
0185:  MOVLW  01
0186:  MOVWF  3F
0187:  MOVF   3F,W
0188:  SUBLW  03
0189:  BTFSS  03.0
018A:  GOTO   193
....................    { 
....................        lcd_send_nibble(3); 
018B:  MOVLW  03
018C:  MOVWF  54
018D:  CALL   11D
....................        delay_ms(5); 
018E:  MOVLW  05
018F:  MOVWF  4D
0190:  CALL   108
0191:  INCF   3F,F
0192:  GOTO   187
....................    } 
....................     
....................    lcd_send_nibble(2); 
0193:  MOVLW  02
0194:  MOVWF  54
0195:  CALL   11D
....................    delay_ms(5); 
0196:  MOVLW  05
0197:  MOVWF  4D
0198:  CALL   108
....................    for(i=0;i<=3;++i) 
0199:  CLRF   3F
019A:  MOVF   3F,W
019B:  SUBLW  03
019C:  BTFSS  03.0
019D:  GOTO   1AA
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
019E:  MOVLW  40
019F:  ADDWF  3F,W
01A0:  MOVWF  04
01A1:  BCF    03.7
01A2:  MOVF   00,W
01A3:  MOVWF  44
01A4:  CLRF   51
01A5:  MOVF   44,W
01A6:  MOVWF  52
01A7:  CALL   12F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01A8:  INCF   3F,F
01A9:  GOTO   19A
01AA:  BSF    0A.3
01AB:  BCF    0A.4
01AC:  GOTO   2BE (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
01AD:  DECFSZ 4E,W
01AE:  GOTO   1B0
01AF:  GOTO   1B3
....................       address=LCD_LINE_TWO; 
01B0:  MOVLW  40
01B1:  MOVWF  4F
01B2:  GOTO   1B4
....................    else 
....................       address=0; 
01B3:  CLRF   4F
....................       
....................    address+=x-1; 
01B4:  MOVLW  01
01B5:  SUBWF  4D,W
01B6:  ADDWF  4F,F
....................    lcd_send_byte(0,0x80|address); 
01B7:  MOVF   4F,W
01B8:  IORLW  80
01B9:  MOVWF  50
01BA:  CLRF   51
01BB:  MOVF   50,W
01BC:  MOVWF  52
01BD:  CALL   12F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01BE:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01BF:  MOVF   4C,W
01C0:  XORLW  07
01C1:  BTFSC  03.2
01C2:  GOTO   1CD
01C3:  XORLW  0B
01C4:  BTFSC  03.2
01C5:  GOTO   1D2
01C6:  XORLW  06
01C7:  BTFSC  03.2
01C8:  GOTO   1DA
01C9:  XORLW  02
01CA:  BTFSC  03.2
01CB:  GOTO   1E0
01CC:  GOTO   1E5
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01CD:  MOVLW  01
01CE:  MOVWF  4D
01CF:  MOVWF  4E
01D0:  CALL   1AD
01D1:  GOTO   1EA
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01D2:  CLRF   51
01D3:  MOVLW  01
01D4:  MOVWF  52
01D5:  CALL   12F
....................                      delay_ms(2); 
01D6:  MOVLW  02
01D7:  MOVWF  4D
01D8:  CALL   108
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01D9:  GOTO   1EA
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01DA:  MOVLW  01
01DB:  MOVWF  4D
01DC:  MOVLW  02
01DD:  MOVWF  4E
01DE:  CALL   1AD
01DF:  GOTO   1EA
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01E0:  CLRF   51
01E1:  MOVLW  10
01E2:  MOVWF  52
01E3:  CALL   12F
01E4:  GOTO   1EA
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01E5:  MOVLW  01
01E6:  MOVWF  51
01E7:  MOVF   4C,W
01E8:  MOVWF  52
01E9:  CALL   12F
....................      #endif 
....................    } 
01EA:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include<DHT11.c> 
.................... /* #include <DHT11.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 10/04/2019 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AB7:  BCF    03.6
0AB8:  CLRF   21
0AB9:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
058F:  CLRF   55
0590:  CLRF   54
0591:  CLRF   53
0592:  MOVLW  7F
0593:  MOVWF  52
0594:  CLRF   59
0595:  CLRF   58
0596:  CLRF   57
0597:  CLRF   56
0598:  BSF    5A.0
0599:  BCF    5A.1
059A:  BCF    5A.2
059B:  CLRF   5C
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
059C:  MOVF   4E,W
059D:  IORWF  4F,W
059E:  BTFSS  03.2
059F:  GOTO   5A5
....................       return 0; 
05A0:  CLRF   77
05A1:  CLRF   78
05A2:  CLRF   79
05A3:  CLRF   7A
05A4:  GOTO   6B0
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
05A5:  MOVF   5C,W
05A6:  INCF   5C,F
05A7:  ADDWF  4E,W
05A8:  MOVWF  04
05A9:  BCF    03.7
05AA:  BTFSC  4F.0
05AB:  BSF    03.7
05AC:  MOVF   00,W
05AD:  MOVWF  5B
05AE:  MOVF   5B,F
05AF:  BTFSC  03.2
05B0:  GOTO   66E
....................    { 
....................       if (skip && !isspace(c)) 
05B1:  BTFSS  5A.0
05B2:  GOTO   5C5
05B3:  MOVF   5B,W
05B4:  SUBLW  20
05B5:  BTFSC  03.2
05B6:  GOTO   5C5
....................       { 
....................          skip = 0; 
05B7:  BCF    5A.0
....................          if (c == '+') 
05B8:  MOVF   5B,W
05B9:  SUBLW  2B
05BA:  BTFSS  03.2
05BB:  GOTO   5BF
....................          { 
....................             sign = 0; 
05BC:  BCF    5A.1
....................             continue; 
05BD:  GOTO   664
....................          }             
05BE:  GOTO   5C5
....................          else if (c == '-') 
05BF:  MOVF   5B,W
05C0:  SUBLW  2D
05C1:  BTFSS  03.2
05C2:  GOTO   5C5
....................          { 
....................             sign = 1; 
05C3:  BSF    5A.1
....................             continue; 
05C4:  GOTO   664
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
05C5:  BTFSC  5A.0
05C6:  GOTO   5CF
05C7:  MOVF   5B,W
05C8:  SUBLW  2E
05C9:  BTFSS  03.2
05CA:  GOTO   5CF
05CB:  BTFSC  5A.2
05CC:  GOTO   5CF
....................          point = 1; 
05CD:  BSF    5A.2
05CE:  GOTO   664
....................       else if (!skip && isdigit(c)) 
05CF:  BTFSC  5A.0
05D0:  GOTO   662
05D1:  MOVF   5B,W
05D2:  SUBLW  2F
05D3:  BTFSC  03.0
05D4:  GOTO   662
05D5:  MOVF   5B,W
05D6:  SUBLW  39
05D7:  BTFSS  03.0
05D8:  GOTO   662
....................       { 
....................          c -= '0'; 
05D9:  MOVLW  30
05DA:  SUBWF  5B,F
....................          if (point) 
05DB:  BTFSS  5A.2
05DC:  GOTO   62C
....................          { 
....................             pow10 = pow10 * 10.0; 
05DD:  MOVF   55,W
05DE:  MOVWF  60
05DF:  MOVF   54,W
05E0:  MOVWF  5F
05E1:  MOVF   53,W
05E2:  MOVWF  5E
05E3:  MOVF   52,W
05E4:  MOVWF  5D
05E5:  CLRF   64
05E6:  CLRF   63
05E7:  MOVLW  20
05E8:  MOVWF  62
05E9:  MOVLW  82
05EA:  MOVWF  61
05EB:  CALL   2F2
05EC:  MOVF   7A,W
05ED:  MOVWF  55
05EE:  MOVF   79,W
05EF:  MOVWF  54
05F0:  MOVF   78,W
05F1:  MOVWF  53
05F2:  MOVF   77,W
05F3:  MOVWF  52
....................             result += (float)c / pow10;    
05F4:  CLRF   62
05F5:  MOVF   5B,W
05F6:  MOVWF  61
05F7:  CALL   367
05F8:  MOVF   7A,W
05F9:  MOVWF  60
05FA:  MOVF   79,W
05FB:  MOVWF  5F
05FC:  MOVF   78,W
05FD:  MOVWF  5E
05FE:  MOVF   77,W
05FF:  MOVWF  5D
0600:  MOVF   7A,W
0601:  MOVWF  64
0602:  MOVF   79,W
0603:  MOVWF  63
0604:  MOVF   78,W
0605:  MOVWF  62
0606:  MOVF   77,W
0607:  MOVWF  61
0608:  MOVF   55,W
0609:  MOVWF  68
060A:  MOVF   54,W
060B:  MOVWF  67
060C:  MOVF   53,W
060D:  MOVWF  66
060E:  MOVF   52,W
060F:  MOVWF  65
0610:  CALL   384
0611:  BCF    03.1
0612:  MOVF   59,W
0613:  MOVWF  64
0614:  MOVF   58,W
0615:  MOVWF  63
0616:  MOVF   57,W
0617:  MOVWF  62
0618:  MOVF   56,W
0619:  MOVWF  61
061A:  MOVF   7A,W
061B:  MOVWF  68
061C:  MOVF   79,W
061D:  MOVWF  67
061E:  MOVF   78,W
061F:  MOVWF  66
0620:  MOVF   77,W
0621:  MOVWF  65
0622:  CALL   44E
0623:  MOVF   7A,W
0624:  MOVWF  59
0625:  MOVF   79,W
0626:  MOVWF  58
0627:  MOVF   78,W
0628:  MOVWF  57
0629:  MOVF   77,W
062A:  MOVWF  56
....................          } 
062B:  GOTO   661
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
062C:  CLRF   60
062D:  CLRF   5F
062E:  MOVLW  20
062F:  MOVWF  5E
0630:  MOVLW  82
0631:  MOVWF  5D
0632:  MOVF   59,W
0633:  MOVWF  64
0634:  MOVF   58,W
0635:  MOVWF  63
0636:  MOVF   57,W
0637:  MOVWF  62
0638:  MOVF   56,W
0639:  MOVWF  61
063A:  CALL   2F2
063B:  MOVF   7A,W
063C:  MOVWF  60
063D:  MOVF   79,W
063E:  MOVWF  5F
063F:  MOVF   78,W
0640:  MOVWF  5E
0641:  MOVF   77,W
0642:  MOVWF  5D
0643:  CLRF   62
0644:  MOVF   5B,W
0645:  MOVWF  61
0646:  CALL   367
0647:  BCF    03.1
0648:  MOVF   60,W
0649:  MOVWF  64
064A:  MOVF   5F,W
064B:  MOVWF  63
064C:  MOVF   5E,W
064D:  MOVWF  62
064E:  MOVF   5D,W
064F:  MOVWF  61
0650:  MOVF   7A,W
0651:  MOVWF  68
0652:  MOVF   79,W
0653:  MOVWF  67
0654:  MOVF   78,W
0655:  MOVWF  66
0656:  MOVF   77,W
0657:  MOVWF  65
0658:  CALL   44E
0659:  MOVF   7A,W
065A:  MOVWF  59
065B:  MOVF   79,W
065C:  MOVWF  58
065D:  MOVF   78,W
065E:  MOVWF  57
065F:  MOVF   77,W
0660:  MOVWF  56
....................          } 
....................       } 
0661:  GOTO   664
....................       else if (!skip) 
0662:  BTFSS  5A.0
....................          break; 
0663:  GOTO   66E
0664:  MOVF   5C,W
0665:  INCF   5C,F
0666:  ADDWF  4E,W
0667:  MOVWF  04
0668:  BCF    03.7
0669:  BTFSC  4F.0
066A:  BSF    03.7
066B:  MOVF   00,W
066C:  MOVWF  5B
066D:  GOTO   5AE
....................    } 
....................  
....................    if (sign) 
066E:  BTFSS  5A.1
066F:  GOTO   687
....................       result = -1*result; 
0670:  CLRF   60
0671:  CLRF   5F
0672:  MOVLW  80
0673:  MOVWF  5E
0674:  MOVLW  7F
0675:  MOVWF  5D
0676:  MOVF   59,W
0677:  MOVWF  64
0678:  MOVF   58,W
0679:  MOVWF  63
067A:  MOVF   57,W
067B:  MOVWF  62
067C:  MOVF   56,W
067D:  MOVWF  61
067E:  CALL   2F2
067F:  MOVF   7A,W
0680:  MOVWF  59
0681:  MOVF   79,W
0682:  MOVWF  58
0683:  MOVF   78,W
0684:  MOVWF  57
0685:  MOVF   77,W
0686:  MOVWF  56
....................        
....................    if(endptr) 
0687:  MOVF   50,W
0688:  IORWF  51,W
0689:  BTFSC  03.2
068A:  GOTO   6A8
....................    { 
....................       if (ptr) { 
068B:  MOVF   5C,F
068C:  BTFSC  03.2
068D:  GOTO   69D
....................          ptr--; 
068E:  DECF   5C,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
068F:  MOVF   50,W
0690:  MOVWF  04
0691:  BCF    03.7
0692:  BTFSC  51.0
0693:  BSF    03.7
0694:  MOVF   5C,W
0695:  ADDWF  4E,W
0696:  MOVWF  00
0697:  INCF   04,F
0698:  MOVF   4F,W
0699:  MOVWF  00
069A:  BTFSC  03.0
069B:  INCF   00,F
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
069C:  GOTO   6A8
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
069D:  MOVF   50,W
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  BTFSC  51.0
06A1:  BSF    03.7
06A2:  INCF   04,F
06A3:  MOVF   4F,W
06A4:  MOVWF  00
06A5:  DECF   04,F
06A6:  MOVF   4E,W
06A7:  MOVWF  00
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
06A8:  MOVF   56,W
06A9:  MOVWF  77
06AA:  MOVF   57,W
06AB:  MOVWF  78
06AC:  MOVF   58,W
06AD:  MOVWF  79
06AE:  MOVF   59,W
06AF:  MOVWF  7A
06B0:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... int bits[5]; 
....................  
.................... void DHT11_start() 
.................... { 
....................    output_drive(DHT11_PIN); 
*
06B2:  BSF    03.5
06B3:  BCF    05.0
....................    output_low(DHT11_PIN); 
06B4:  BCF    05.0
06B5:  BCF    03.5
06B6:  BCF    05.0
....................    delay_ms(25); 
06B7:  MOVLW  19
06B8:  MOVWF  4D
06B9:  CALL   108
....................    output_high(DHT11_PIN); 
06BA:  BSF    03.5
06BB:  BCF    05.0
06BC:  BCF    03.5
06BD:  BSF    05.0
....................    delay_us(30); 
06BE:  MOVLW  09
06BF:  MOVWF  77
06C0:  DECFSZ 77,F
06C1:  GOTO   6C0
06C2:  GOTO   6C3
....................    output_float(DHT11_PIN); 
06C3:  BSF    03.5
06C4:  BSF    05.0
.................... } 
....................  
.................... void DHT11_response() 
.................... { 
....................    while(input_state(DHT11_PIN)){}; 
06C5:  BCF    03.5
06C6:  BTFSC  05.0
06C7:  GOTO   6C6
....................    while(!input_state(DHT11_PIN)){}; 
06C8:  BTFSS  05.0
06C9:  GOTO   6C8
....................    while(input_state(DHT11_PIN)){};   
06CA:  BTFSC  05.0
06CB:  GOTO   6CA
.................... } 
....................  
.................... int DHT11_read_byte() 
*
025C:  CLRF   4D
.................... { 
....................    int i,data = 0;   
....................    for(i=0;i<8;i++){         
025D:  CLRF   4C
025E:  MOVF   4C,W
025F:  SUBLW  07
0260:  BTFSS  03.0
0261:  GOTO   276
....................       while(!input_state(DHT11_PIN)){ 
0262:  BTFSS  05.0
0263:  GOTO   262
....................       } 
....................       delay_us(30);          
0264:  MOVLW  09
0265:  MOVWF  77
0266:  DECFSZ 77,F
0267:  GOTO   266
0268:  GOTO   269
....................       if(input_state(DHT11_PIN)){   
0269:  BTFSS  05.0
026A:  GOTO   270
....................          data = ((data<<1) | 1);  
026B:  BCF    03.0
026C:  RLF    4D,W
026D:  IORLW  01
026E:  MOVWF  4D
....................       } 
026F:  GOTO   272
....................       else{ 
....................          data = (data<<1);   
0270:  BCF    03.0
0271:  RLF    4D,F
....................       } 
....................       while(input_state(DHT11_PIN)){ 
0272:  BTFSC  05.0
0273:  GOTO   272
....................       } 
0274:  INCF   4C,F
0275:  GOTO   25E
....................    } 
....................    return data; 
0276:  MOVF   4D,W
0277:  MOVWF  78
0278:  RETURN
.................... } 
....................  
.................... int DHT11_read_data(float *hum, float *temp) 
*
06B1:  CLRF   4B
.................... { 
....................    char buf[8]; 
....................    int result = 0; 
....................    DHT11_start(); 
....................    DHT11_response(); 
....................    bits[0] = DHT11_read_byte();   //Humedad entero 
*
06CC:  CALL   25C
06CD:  MOVF   78,W
06CE:  MOVWF  27
....................    bits[1] = DHT11_read_byte();   //Humedad decimal 
06CF:  CALL   25C
06D0:  MOVF   78,W
06D1:  MOVWF  28
....................    bits[2] = DHT11_read_byte();   //Temp entero 
06D2:  CALL   25C
06D3:  MOVF   78,W
06D4:  MOVWF  29
....................    bits[3] = DHT11_read_byte();   //Temp decimal 
06D5:  CALL   25C
06D6:  MOVF   78,W
06D7:  MOVWF  2A
....................    bits[4] = DHT11_read_byte();   //Paridad 
06D8:  CALL   25C
06D9:  MOVF   78,W
06DA:  MOVWF  2B
....................    result = bits[0] + bits[1] + bits[2] + bits[3]; 
06DB:  MOVF   28,W
06DC:  ADDWF  27,W
06DD:  ADDWF  29,W
06DE:  ADDWF  2A,W
06DF:  MOVWF  4B
....................    if (result == bits[4]){ 
06E0:  MOVF   2B,W
06E1:  SUBWF  4B,W
06E2:  BTFSS  03.2
06E3:  GOTO   740
....................       sprintf(buf, "%2d.%1d",bits[0],bits[1]); 
06E4:  CLRF   2D
06E5:  MOVLW  43
06E6:  MOVWF  2C
06E7:  MOVF   27,W
06E8:  MOVWF  4C
06E9:  MOVLW  11
06EA:  MOVWF  4D
06EB:  CALL   29B
06EC:  MOVLW  2E
06ED:  MOVWF  52
06EE:  CALL   28E
06EF:  MOVF   28,W
06F0:  MOVWF  4C
06F1:  MOVLW  18
06F2:  MOVWF  4D
06F3:  CALL   29B
....................       *hum = atof(buf); 
06F4:  MOVF   40,W
06F5:  MOVWF  7A
06F6:  MOVF   3F,W
06F7:  MOVWF  4C
06F8:  MOVF   40,W
06F9:  MOVWF  4D
06FA:  CLRF   4F
06FB:  MOVLW  43
06FC:  MOVWF  4E
06FD:  CLRF   51
06FE:  CLRF   50
06FF:  CALL   58F
0700:  MOVF   4C,W
0701:  MOVWF  04
0702:  BCF    03.7
0703:  BTFSC  4D.0
0704:  BSF    03.7
0705:  MOVF   77,W
0706:  MOVWF  00
0707:  INCF   04,F
0708:  MOVF   78,W
0709:  MOVWF  00
070A:  INCF   04,F
070B:  MOVF   79,W
070C:  MOVWF  00
070D:  INCF   04,F
070E:  MOVF   7A,W
070F:  MOVWF  00
....................       sprintf(buf, "%2d.%1d",bits[2],bits[3]); 
0710:  CLRF   2D
0711:  MOVLW  43
0712:  MOVWF  2C
0713:  MOVF   29,W
0714:  MOVWF  4C
0715:  MOVLW  11
0716:  MOVWF  4D
0717:  CALL   29B
0718:  MOVLW  2E
0719:  MOVWF  52
071A:  CALL   28E
071B:  MOVF   2A,W
071C:  MOVWF  4C
071D:  MOVLW  18
071E:  MOVWF  4D
071F:  CALL   29B
....................       *temp = atof(buf);   
0720:  MOVF   42,W
0721:  MOVWF  7A
0722:  MOVF   41,W
0723:  MOVWF  4C
0724:  MOVF   42,W
0725:  MOVWF  4D
0726:  CLRF   4F
0727:  MOVLW  43
0728:  MOVWF  4E
0729:  CLRF   51
072A:  CLRF   50
072B:  CALL   58F
072C:  MOVF   4C,W
072D:  MOVWF  04
072E:  BCF    03.7
072F:  BTFSC  4D.0
0730:  BSF    03.7
0731:  MOVF   77,W
0732:  MOVWF  00
0733:  INCF   04,F
0734:  MOVF   78,W
0735:  MOVWF  00
0736:  INCF   04,F
0737:  MOVF   79,W
0738:  MOVWF  00
0739:  INCF   04,F
073A:  MOVF   7A,W
073B:  MOVWF  00
....................       return 1; 
073C:  MOVLW  01
073D:  MOVWF  78
073E:  GOTO   742
....................    } 
073F:  GOTO   742
....................    else{ 
....................       return 0; 
0740:  MOVLW  00
0741:  MOVWF  78
....................    } 
0742:  RETURN
.................... } 
....................  
.................... //Consntantes de conversion 
.................... #define faCentigrados 1.8 
....................  
.................... void main(){ 
*
0A8F:  MOVF   03,W
0A90:  ANDLW  1F
0A91:  MOVWF  03
0A92:  MOVLW  61
0A93:  BSF    03.5
0A94:  MOVWF  0F
0A95:  MOVF   0F,W
0A96:  BCF    03.5
0A97:  CLRF   20
0A98:  BSF    03.5
0A99:  BSF    03.6
0A9A:  BCF    07.3
0A9B:  MOVLW  19
0A9C:  BCF    03.6
0A9D:  MOVWF  19
0A9E:  MOVLW  A6
0A9F:  MOVWF  18
0AA0:  MOVLW  90
0AA1:  BCF    03.5
0AA2:  MOVWF  18
0AA3:  CLRF   2D
0AA4:  CLRF   2C
0AA5:  MOVLW  FF
0AA6:  MOVWF  2E
0AA7:  BSF    03.5
0AA8:  BSF    03.6
0AA9:  MOVF   09,W
0AAA:  ANDLW  C0
0AAB:  MOVWF  09
0AAC:  BCF    03.6
0AAD:  BCF    1F.4
0AAE:  BCF    1F.5
0AAF:  MOVLW  00
0AB0:  BSF    03.6
0AB1:  MOVWF  08
0AB2:  BCF    03.5
0AB3:  CLRF   07
0AB4:  CLRF   08
0AB5:  CLRF   09
0AB6:  BCF    03.7
*
0ABA:  CLRF   2F
0ABB:  CLRF   30
....................    //Variable donde se almacenara el valor del ADC de los sensores de peruta y temperatura respectivamente 
....................    int puerta = 0, data_ok = 0; 
....................    float temperatura,centigrados, humedad; 
....................    char modo; 
....................     
....................    // variable para salir de un modo 
....................    char salir; 
....................    // se inicializa la funcion del LCD 
....................    lcd_init();  
0ABC:  BCF    0A.3
0ABD:  GOTO   16F
0ABE:  BSF    0A.3
....................     
....................     
....................    //Imprimir mensaje de preparacion en la LCD 
....................    lcd_putc("\fReady...\n"); 
0ABF:  MOVLW  04
0AC0:  BSF    03.6
0AC1:  MOVWF  0D
0AC2:  MOVLW  00
0AC3:  MOVWF  0F
0AC4:  BCF    0A.3
0AC5:  BCF    03.6
0AC6:  CALL   1EB
0AC7:  BSF    0A.3
....................    delay_ms(2000); 
0AC8:  MOVLW  08
0AC9:  MOVWF  3F
0ACA:  MOVLW  FA
0ACB:  MOVWF  4D
0ACC:  BCF    0A.3
0ACD:  CALL   108
0ACE:  BSF    0A.3
0ACF:  DECFSZ 3F,F
0AD0:  GOTO   2CA
....................    //Comienzo del programa 
....................    while(TRUE) 
....................    {      
....................       //Limpiar la LCD 
....................       printf(lcd_putc, "\f"); 
0AD1:  MOVLW  0C
0AD2:  MOVWF  4C
0AD3:  BCF    0A.3
0AD4:  CALL   1BF
0AD5:  BSF    0A.3
....................        
....................       //Solicitud de Modo de trabajo 
....................       while(true) 
....................       { 
....................          printf(lcd_putc,"\f"); 
0AD6:  MOVLW  0C
0AD7:  MOVWF  4C
0AD8:  BCF    0A.3
0AD9:  CALL   1BF
0ADA:  BSF    0A.3
....................          printf("\n\r"); 
0ADB:  MOVLW  0A
0ADC:  BTFSS  0C.4
0ADD:  GOTO   2DC
0ADE:  MOVWF  19
0ADF:  MOVLW  0D
0AE0:  BTFSS  0C.4
0AE1:  GOTO   2E0
0AE2:  MOVWF  19
....................          //apagar los actuadores 
....................          //ventilador       
....................          output_low(PIN_C1); 
0AE3:  BCF    2E.1
0AE4:  MOVF   2E,W
0AE5:  BSF    03.5
0AE6:  MOVWF  07
0AE7:  BCF    03.5
0AE8:  BCF    07.1
....................          output_low(PIN_C2); 
0AE9:  BCF    2E.2
0AEA:  MOVF   2E,W
0AEB:  BSF    03.5
0AEC:  MOVWF  07
0AED:  BCF    03.5
0AEE:  BCF    07.2
....................          puerta = 0; 
0AEF:  CLRF   2F
....................          //led de advertencia 
....................          output_low(PIN_C0); 
0AF0:  BCF    2E.0
0AF1:  MOVF   2E,W
0AF2:  BSF    03.5
0AF3:  MOVWF  07
0AF4:  BCF    03.5
0AF5:  BCF    07.0
....................          lcd_gotoxy(1,1); 
0AF6:  MOVLW  01
0AF7:  MOVWF  4D
0AF8:  MOVWF  4E
0AF9:  BCF    0A.3
0AFA:  CALL   1AD
0AFB:  BSF    0A.3
....................          printf(lcd_putc,"Seleccion modo"); 
0AFC:  MOVLW  0A
0AFD:  BSF    03.6
0AFE:  MOVWF  0D
0AFF:  MOVLW  00
0B00:  MOVWF  0F
0B01:  BCF    0A.3
0B02:  BCF    03.6
0B03:  CALL   1EB
0B04:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0B05:  MOVLW  01
0B06:  MOVWF  4D
0B07:  MOVLW  02
0B08:  MOVWF  4E
0B09:  BCF    0A.3
0B0A:  CALL   1AD
0B0B:  BSF    0A.3
....................          printf(lcd_putc,"a:Auto | b:Man"); 
0B0C:  MOVLW  12
0B0D:  BSF    03.6
0B0E:  MOVWF  0D
0B0F:  MOVLW  00
0B10:  MOVWF  0F
0B11:  BCF    0A.3
0B12:  BCF    03.6
0B13:  CALL   1EB
0B14:  BSF    0A.3
....................          //ingreso de modo de trabajo 
....................          modo = getch(); 
0B15:  BCF    0A.3
0B16:  CALL   241
0B17:  BSF    0A.3
0B18:  MOVF   78,W
0B19:  MOVWF  3D
....................          if(modo == 'a' || modo == 'b'){ 
0B1A:  MOVF   3D,W
0B1B:  SUBLW  61
0B1C:  BTFSC  03.2
0B1D:  GOTO   321
0B1E:  MOVF   3D,W
0B1F:  SUBLW  62
0B20:  BTFSC  03.2
....................             break; 
0B21:  GOTO   32C
....................          } 
....................           
....................          delay_ms(500); 
0B22:  MOVLW  02
0B23:  MOVWF  3F
0B24:  MOVLW  FA
0B25:  MOVWF  4D
0B26:  BCF    0A.3
0B27:  CALL   108
0B28:  BSF    0A.3
0B29:  DECFSZ 3F,F
0B2A:  GOTO   324
0B2B:  GOTO   2D6
....................       } 
....................        
....................       //En caso de modo A: ADC 
....................       switch(modo){ 
0B2C:  MOVF   3D,W
0B2D:  XORLW  61
0B2E:  BTFSC  03.2
0B2F:  GOTO   334
0B30:  XORLW  03
0B31:  BTFSC  03.2
0B32:  GOTO   54C
0B33:  GOTO   76D
....................          case 'a': 
....................          { 
....................              
....................             while(true) 
....................             { 
....................                //lectura de temperatura 
....................                data_ok = DHT11_read_data(&temperatura,&humedad); 
0B34:  CLRF   40
0B35:  MOVLW  31
0B36:  MOVWF  3F
0B37:  CLRF   42
0B38:  MOVLW  39
0B39:  MOVWF  41
0B3A:  BCF    0A.3
0B3B:  CALL   6B1
0B3C:  BSF    0A.3
0B3D:  MOVF   78,W
0B3E:  MOVWF  30
....................                //lectura de puerta 
....................                puerta = input(spuerta); 
0B3F:  BSF    03.5
0B40:  BSF    05.1
0B41:  BCF    03.5
0B42:  CLRF   2F
0B43:  BTFSC  05.1
0B44:  INCF   2F,F
....................                //Imprimir en LCD 
....................                printf(lcd_putc, "\f"); 
0B45:  MOVLW  0C
0B46:  MOVWF  4C
0B47:  BCF    0A.3
0B48:  CALL   1BF
0B49:  BSF    0A.3
....................                lcd_gotoxy(1,1); 
0B4A:  MOVLW  01
0B4B:  MOVWF  4D
0B4C:  MOVWF  4E
0B4D:  BCF    0A.3
0B4E:  CALL   1AD
0B4F:  BSF    0A.3
....................                printf(lcd_putc, "m:Auto"); 
0B50:  MOVLW  1A
0B51:  BSF    03.6
0B52:  MOVWF  0D
0B53:  MOVLW  00
0B54:  MOVWF  0F
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  CALL   1EB
0B58:  BSF    0A.3
....................                if(puerta == 0){ 
0B59:  MOVF   2F,F
0B5A:  BTFSS  03.2
0B5B:  GOTO   36D
....................                   lcd_gotoxy(8,1); 
0B5C:  MOVLW  08
0B5D:  MOVWF  4D
0B5E:  MOVLW  01
0B5F:  MOVWF  4E
0B60:  BCF    0A.3
0B61:  CALL   1AD
0B62:  BSF    0A.3
....................                   printf(lcd_putc, "Pue:Open\n\r"); 
0B63:  MOVLW  1E
0B64:  BSF    03.6
0B65:  MOVWF  0D
0B66:  MOVLW  00
0B67:  MOVWF  0F
0B68:  BCF    0A.3
0B69:  BCF    03.6
0B6A:  CALL   1EB
0B6B:  BSF    0A.3
....................                }else{ 
0B6C:  GOTO   37D
....................                   lcd_gotoxy(8,1); 
0B6D:  MOVLW  08
0B6E:  MOVWF  4D
0B6F:  MOVLW  01
0B70:  MOVWF  4E
0B71:  BCF    0A.3
0B72:  CALL   1AD
0B73:  BSF    0A.3
....................                   printf(lcd_putc, "Pue:Close"); 
0B74:  MOVLW  24
0B75:  BSF    03.6
0B76:  MOVWF  0D
0B77:  MOVLW  00
0B78:  MOVWF  0F
0B79:  BCF    0A.3
0B7A:  BCF    03.6
0B7B:  CALL   1EB
0B7C:  BSF    0A.3
....................                } 
....................                //Lectura de temperatura 
....................                if(data_ok == 1) 
0B7D:  DECFSZ 30,W
0B7E:  GOTO   51D
....................                { 
....................                   //calculo de grados centigrados 
....................                   centigrados = (temperatura - 32)/faCentigrados; 
0B7F:  BSF    03.1
0B80:  MOVF   34,W
0B81:  MOVWF  64
0B82:  MOVF   33,W
0B83:  MOVWF  63
0B84:  MOVF   32,W
0B85:  MOVWF  62
0B86:  MOVF   31,W
0B87:  MOVWF  61
0B88:  CLRF   68
0B89:  CLRF   67
0B8A:  CLRF   66
0B8B:  MOVLW  84
0B8C:  MOVWF  65
0B8D:  BCF    0A.3
0B8E:  CALL   44E
0B8F:  BSF    0A.3
0B90:  MOVF   7A,W
0B91:  MOVWF  42
0B92:  MOVF   79,W
0B93:  MOVWF  41
0B94:  MOVF   78,W
0B95:  MOVWF  40
0B96:  MOVF   77,W
0B97:  MOVWF  3F
0B98:  MOVF   7A,W
0B99:  MOVWF  64
0B9A:  MOVF   79,W
0B9B:  MOVWF  63
0B9C:  MOVF   78,W
0B9D:  MOVWF  62
0B9E:  MOVF   77,W
0B9F:  MOVWF  61
0BA0:  MOVLW  66
0BA1:  MOVWF  68
0BA2:  MOVWF  67
0BA3:  MOVWF  66
0BA4:  MOVLW  7F
0BA5:  MOVWF  65
0BA6:  BCF    0A.3
0BA7:  CALL   384
0BA8:  BSF    0A.3
0BA9:  MOVF   7A,W
0BAA:  MOVWF  38
0BAB:  MOVF   79,W
0BAC:  MOVWF  37
0BAD:  MOVF   78,W
0BAE:  MOVWF  36
0BAF:  MOVF   77,W
0BB0:  MOVWF  35
....................                   //salidas 
....................                   lcd_gotoxy(1,2); 
0BB1:  MOVLW  01
0BB2:  MOVWF  4D
0BB3:  MOVLW  02
0BB4:  MOVWF  4E
0BB5:  BCF    0A.3
0BB6:  CALL   1AD
0BB7:  BSF    0A.3
....................                   printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0BB8:  MOVLW  54
0BB9:  MOVWF  4C
0BBA:  BCF    0A.3
0BBB:  CALL   1BF
0BBC:  BSF    0A.3
0BBD:  MOVLW  3A
0BBE:  MOVWF  4C
0BBF:  BCF    0A.3
0BC0:  CALL   1BF
0BC1:  BSF    0A.3
0BC2:  MOVLW  20
0BC3:  MOVWF  4C
0BC4:  BCF    0A.3
0BC5:  CALL   1BF
0BC6:  BSF    0A.3
0BC7:  MOVLW  89
0BC8:  MOVWF  04
0BC9:  MOVF   38,W
0BCA:  MOVWF  42
0BCB:  MOVF   37,W
0BCC:  MOVWF  41
0BCD:  MOVF   36,W
0BCE:  MOVWF  40
0BCF:  MOVF   35,W
0BD0:  MOVWF  3F
0BD1:  MOVLW  01
0BD2:  MOVWF  43
0BD3:  CALL   000
0BD4:  MOVLW  20
0BD5:  MOVWF  4C
0BD6:  BCF    0A.3
0BD7:  CALL   1BF
0BD8:  BSF    0A.3
0BD9:  MOVLW  DF
0BDA:  MOVWF  4C
0BDB:  BCF    0A.3
0BDC:  CALL   1BF
0BDD:  BSF    0A.3
0BDE:  MOVLW  43
0BDF:  MOVWF  4C
0BE0:  BCF    0A.3
0BE1:  CALL   1BF
0BE2:  BSF    0A.3
....................                   // calculos de temperatura 
....................                   if (centigrados >= 15 && centigrados <= 30 && puerta == 1) { 
0BE3:  CLRF   42
0BE4:  CLRF   41
0BE5:  MOVLW  70
0BE6:  MOVWF  40
0BE7:  MOVLW  82
0BE8:  MOVWF  3F
0BE9:  MOVF   38,W
0BEA:  MOVWF  46
0BEB:  MOVF   37,W
0BEC:  MOVWF  45
0BED:  MOVF   36,W
0BEE:  MOVWF  44
0BEF:  MOVF   35,W
0BF0:  MOVWF  43
0BF1:  BCF    0A.3
0BF2:  CALL   7B1
0BF3:  BSF    0A.3
0BF4:  BTFSC  03.0
0BF5:  GOTO   3F8
0BF6:  BTFSS  03.2
0BF7:  GOTO   462
0BF8:  MOVF   38,W
0BF9:  MOVWF  42
0BFA:  MOVF   37,W
0BFB:  MOVWF  41
0BFC:  MOVF   36,W
0BFD:  MOVWF  40
0BFE:  MOVF   35,W
0BFF:  MOVWF  3F
0C00:  CLRF   46
0C01:  CLRF   45
0C02:  MOVLW  70
0C03:  MOVWF  44
0C04:  MOVLW  83
0C05:  MOVWF  43
0C06:  BCF    0A.3
0C07:  CALL   7B1
0C08:  BSF    0A.3
0C09:  BTFSC  03.0
0C0A:  GOTO   40D
0C0B:  BTFSS  03.2
0C0C:  GOTO   462
0C0D:  DECFSZ 2F,W
0C0E:  GOTO   462
....................                      //ventilador       
....................                      output_high(PIN_C1); 
0C0F:  BCF    2E.1
0C10:  MOVF   2E,W
0C11:  BSF    03.5
0C12:  MOVWF  07
0C13:  BCF    03.5
0C14:  BSF    07.1
....................                      output_low(PIN_C2); 
0C15:  BCF    2E.2
0C16:  MOVF   2E,W
0C17:  BSF    03.5
0C18:  MOVWF  07
0C19:  BCF    03.5
0C1A:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0C1B:  MOVLW  0C
0C1C:  MOVWF  4D
0C1D:  MOVLW  02
0C1E:  MOVWF  4E
0C1F:  BCF    0A.3
0C20:  CALL   1AD
0C21:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0C22:  MOVLW  29
0C23:  BSF    03.6
0C24:  MOVWF  0D
0C25:  MOVLW  00
0C26:  MOVWF  0F
0C27:  BCF    0A.3
0C28:  BCF    03.6
0C29:  CALL   1EB
0C2A:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f (C)  |   Puerta: %u   |   Ventilador: ON\n\r",centigrados, puerta); 
0C2B:  MOVLW  2C
0C2C:  BSF    03.6
0C2D:  MOVWF  0D
0C2E:  MOVLW  00
0C2F:  MOVWF  0F
0C30:  BCF    03.0
0C31:  MOVLW  11
0C32:  BCF    03.6
0C33:  MOVWF  3F
0C34:  CALL   0D3
0C35:  MOVLW  89
0C36:  MOVWF  04
0C37:  MOVF   38,W
0C38:  MOVWF  42
0C39:  MOVF   37,W
0C3A:  MOVWF  41
0C3B:  MOVF   36,W
0C3C:  MOVWF  40
0C3D:  MOVF   35,W
0C3E:  MOVWF  3F
0C3F:  MOVLW  01
0C40:  MOVWF  43
0C41:  CALL   12C
0C42:  MOVLW  36
0C43:  BSF    03.6
0C44:  MOVWF  0D
0C45:  MOVLW  00
0C46:  MOVWF  0F
0C47:  BSF    03.0
0C48:  MOVLW  12
0C49:  BCF    03.6
0C4A:  MOVWF  3F
0C4B:  CALL   0D3
0C4C:  MOVF   2F,W
0C4D:  MOVWF  3F
0C4E:  MOVLW  1B
0C4F:  MOVWF  40
0C50:  CALL   1FB
0C51:  MOVLW  40
0C52:  BSF    03.6
0C53:  MOVWF  0D
0C54:  MOVLW  00
0C55:  MOVWF  0F
0C56:  BSF    03.0
0C57:  MOVLW  17
0C58:  BCF    03.6
0C59:  MOVWF  3F
0C5A:  CALL   0D3
....................                      //led de advertencia 
....................                      output_low(PIN_C0); 
0C5B:  BCF    2E.0
0C5C:  MOVF   2E,W
0C5D:  BSF    03.5
0C5E:  MOVWF  07
0C5F:  BCF    03.5
0C60:  BCF    07.0
....................                   } else if (centigrados > 30 && puerta == 1) { 
0C61:  GOTO   51C
0C62:  CLRF   42
0C63:  CLRF   41
0C64:  MOVLW  70
0C65:  MOVWF  40
0C66:  MOVLW  83
0C67:  MOVWF  3F
0C68:  MOVF   38,W
0C69:  MOVWF  46
0C6A:  MOVF   37,W
0C6B:  MOVWF  45
0C6C:  MOVF   36,W
0C6D:  MOVWF  44
0C6E:  MOVF   35,W
0C6F:  MOVWF  43
0C70:  BCF    0A.3
0C71:  CALL   7B1
0C72:  BSF    0A.3
0C73:  BTFSS  03.0
0C74:  GOTO   4CA
0C75:  DECFSZ 2F,W
0C76:  GOTO   4CA
....................                      //ventilador       
....................                      output_high(PIN_C1); 
0C77:  BCF    2E.1
0C78:  MOVF   2E,W
0C79:  BSF    03.5
0C7A:  MOVWF  07
0C7B:  BCF    03.5
0C7C:  BSF    07.1
....................                      output_low(PIN_C2); 
0C7D:  BCF    2E.2
0C7E:  MOVF   2E,W
0C7F:  BSF    03.5
0C80:  MOVWF  07
0C81:  BCF    03.5
0C82:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0C83:  MOVLW  0C
0C84:  MOVWF  4D
0C85:  MOVLW  02
0C86:  MOVWF  4E
0C87:  BCF    0A.3
0C88:  CALL   1AD
0C89:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0C8A:  MOVLW  4D
0C8B:  BSF    03.6
0C8C:  MOVWF  0D
0C8D:  MOVLW  00
0C8E:  MOVWF  0F
0C8F:  BCF    0A.3
0C90:  BCF    03.6
0C91:  CALL   1EB
0C92:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f (C)(Precaucion)|Puerta: %u|Ventilador: ON\n\r",centigrados, puerta); 
0C93:  MOVLW  50
0C94:  BSF    03.6
0C95:  MOVWF  0D
0C96:  MOVLW  00
0C97:  MOVWF  0F
0C98:  BCF    03.0
0C99:  MOVLW  11
0C9A:  BCF    03.6
0C9B:  MOVWF  3F
0C9C:  CALL   0D3
0C9D:  MOVLW  89
0C9E:  MOVWF  04
0C9F:  MOVF   38,W
0CA0:  MOVWF  42
0CA1:  MOVF   37,W
0CA2:  MOVWF  41
0CA3:  MOVF   36,W
0CA4:  MOVWF  40
0CA5:  MOVF   35,W
0CA6:  MOVWF  3F
0CA7:  MOVLW  01
0CA8:  MOVWF  43
0CA9:  CALL   12C
0CAA:  MOVLW  5A
0CAB:  BSF    03.6
0CAC:  MOVWF  0D
0CAD:  MOVLW  00
0CAE:  MOVWF  0F
0CAF:  BSF    03.0
0CB0:  MOVLW  19
0CB1:  BCF    03.6
0CB2:  MOVWF  3F
0CB3:  CALL   0D3
0CB4:  MOVF   2F,W
0CB5:  MOVWF  3F
0CB6:  MOVLW  1B
0CB7:  MOVWF  40
0CB8:  CALL   1FB
0CB9:  MOVLW  68
0CBA:  BSF    03.6
0CBB:  MOVWF  0D
0CBC:  MOVLW  00
0CBD:  MOVWF  0F
0CBE:  BCF    03.0
0CBF:  MOVLW  11
0CC0:  BCF    03.6
0CC1:  MOVWF  3F
0CC2:  CALL   0D3
....................                      //led de advertencia 
....................                      output_high(PIN_C0); 
0CC3:  BCF    2E.0
0CC4:  MOVF   2E,W
0CC5:  BSF    03.5
0CC6:  MOVWF  07
0CC7:  BCF    03.5
0CC8:  BSF    07.0
....................                   } else { 
0CC9:  GOTO   51C
....................                      //ventilador       
....................                      output_low(PIN_C1); 
0CCA:  BCF    2E.1
0CCB:  MOVF   2E,W
0CCC:  BSF    03.5
0CCD:  MOVWF  07
0CCE:  BCF    03.5
0CCF:  BCF    07.1
....................                      output_low(PIN_C2); 
0CD0:  BCF    2E.2
0CD1:  MOVF   2E,W
0CD2:  BSF    03.5
0CD3:  MOVWF  07
0CD4:  BCF    03.5
0CD5:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0CD6:  MOVLW  0C
0CD7:  MOVWF  4D
0CD8:  MOVLW  02
0CD9:  MOVWF  4E
0CDA:  BCF    0A.3
0CDB:  CALL   1AD
0CDC:  BSF    0A.3
....................                      printf(lcd_putc, "V:OFF"); 
0CDD:  MOVLW  71
0CDE:  BSF    03.6
0CDF:  MOVWF  0D
0CE0:  MOVLW  00
0CE1:  MOVWF  0F
0CE2:  BCF    0A.3
0CE3:  BCF    03.6
0CE4:  CALL   1EB
0CE5:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f (C)   |   Puerta: %u   |   Ventilador: OFF\n\r",centigrados, puerta); 
0CE6:  MOVLW  74
0CE7:  BSF    03.6
0CE8:  MOVWF  0D
0CE9:  MOVLW  00
0CEA:  MOVWF  0F
0CEB:  BCF    03.0
0CEC:  MOVLW  11
0CED:  BCF    03.6
0CEE:  MOVWF  3F
0CEF:  CALL   0D3
0CF0:  MOVLW  89
0CF1:  MOVWF  04
0CF2:  MOVF   38,W
0CF3:  MOVWF  42
0CF4:  MOVF   37,W
0CF5:  MOVWF  41
0CF6:  MOVF   36,W
0CF7:  MOVWF  40
0CF8:  MOVF   35,W
0CF9:  MOVWF  3F
0CFA:  MOVLW  01
0CFB:  MOVWF  43
0CFC:  CALL   12C
0CFD:  MOVLW  7E
0CFE:  BSF    03.6
0CFF:  MOVWF  0D
0D00:  MOVLW  00
0D01:  MOVWF  0F
0D02:  BSF    03.0
0D03:  MOVLW  13
0D04:  BCF    03.6
0D05:  MOVWF  3F
0D06:  CALL   0D3
0D07:  MOVF   2F,W
0D08:  MOVWF  3F
0D09:  MOVLW  1B
0D0A:  MOVWF  40
0D0B:  CALL   1FB
0D0C:  MOVLW  89
0D0D:  BSF    03.6
0D0E:  MOVWF  0D
0D0F:  MOVLW  00
0D10:  MOVWF  0F
0D11:  BCF    03.0
0D12:  MOVLW  18
0D13:  BCF    03.6
0D14:  MOVWF  3F
0D15:  CALL   0D3
....................                      //led de advertencia 
....................                      output_low(PIN_C0); 
0D16:  BCF    2E.0
0D17:  MOVF   2E,W
0D18:  BSF    03.5
0D19:  MOVWF  07
0D1A:  BCF    03.5
0D1B:  BCF    07.0
....................                      } 
....................                }else{ 
0D1C:  GOTO   534
....................                   //salidas 
....................                   lcd_gotoxy(1,2); 
0D1D:  MOVLW  01
0D1E:  MOVWF  4D
0D1F:  MOVLW  02
0D20:  MOVWF  4E
0D21:  BCF    0A.3
0D22:  CALL   1AD
0D23:  BSF    0A.3
....................                   printf(lcd_putc, "T:NA"); 
0D24:  MOVLW  96
0D25:  BSF    03.6
0D26:  MOVWF  0D
0D27:  MOVLW  00
0D28:  MOVWF  0F
0D29:  BCF    0A.3
0D2A:  BCF    03.6
0D2B:  CALL   1EB
0D2C:  BSF    0A.3
....................                   printf("DESCONECTADO\n\r"); 
0D2D:  MOVLW  99
0D2E:  BSF    03.6
0D2F:  MOVWF  0D
0D30:  MOVLW  00
0D31:  MOVWF  0F
0D32:  BCF    03.6
0D33:  CALL   237
....................                } 
....................        
....................                // se reinicia spuerta 
....................                puerta = 0; 
0D34:  CLRF   2F
....................                //se solicita confirmacion para salir 
....................                salir = getch(); 
0D35:  BCF    0A.3
0D36:  CALL   241
0D37:  BSF    0A.3
0D38:  MOVF   78,W
0D39:  MOVWF  3E
....................                if(salir == 's')  
0D3A:  MOVF   3E,W
0D3B:  SUBLW  73
0D3C:  BTFSC  03.2
....................                { 
....................                   break; 
0D3D:  GOTO   548
....................                } 
....................               
....................                delay_ms(1500); 
0D3E:  MOVLW  06
0D3F:  MOVWF  3F
0D40:  MOVLW  FA
0D41:  MOVWF  4D
0D42:  BCF    0A.3
0D43:  CALL   108
0D44:  BSF    0A.3
0D45:  DECFSZ 3F,F
0D46:  GOTO   540
0D47:  GOTO   334
....................             } 
....................         
....................              
....................          } 
....................           
....................          if(salir == 's') { 
0D48:  MOVF   3E,W
0D49:  SUBLW  73
0D4A:  BTFSC  03.2
....................                   break; 
0D4B:  GOTO   76D
....................          } 
....................           
....................          case 'b': 
....................          { 
....................             while(true) 
....................             { 
....................                //repetir lo siguente 
....................                 
....................                while(true) 
....................                { 
....................                   //Normalmente apagado 
....................                    
....................                   //lectura de temperatura 
....................                   data_ok = DHT11_read_data(&temperatura,&humedad); 
0D4C:  CLRF   40
0D4D:  MOVLW  31
0D4E:  MOVWF  3F
0D4F:  CLRF   42
0D50:  MOVLW  39
0D51:  MOVWF  41
0D52:  BCF    0A.3
0D53:  CALL   6B1
0D54:  BSF    0A.3
0D55:  MOVF   78,W
0D56:  MOVWF  30
....................                   //lectura de puerta 
....................                   puerta = input(spuerta); 
0D57:  BSF    03.5
0D58:  BSF    05.1
0D59:  BCF    03.5
0D5A:  CLRF   2F
0D5B:  BTFSC  05.1
0D5C:  INCF   2F,F
....................                   //Imprimir en LCD 
....................                   printf(lcd_putc, "\f"); 
0D5D:  MOVLW  0C
0D5E:  MOVWF  4C
0D5F:  BCF    0A.3
0D60:  CALL   1BF
0D61:  BSF    0A.3
....................                   lcd_gotoxy(1,1); 
0D62:  MOVLW  01
0D63:  MOVWF  4D
0D64:  MOVWF  4E
0D65:  BCF    0A.3
0D66:  CALL   1AD
0D67:  BSF    0A.3
....................                   printf(lcd_putc, "m:Manu"); 
0D68:  MOVLW  A1
0D69:  BSF    03.6
0D6A:  MOVWF  0D
0D6B:  MOVLW  00
0D6C:  MOVWF  0F
0D6D:  BCF    0A.3
0D6E:  BCF    03.6
0D6F:  CALL   1EB
0D70:  BSF    0A.3
....................                    
....................                   if(data_ok == 1) 
0D71:  DECFSZ 30,W
0D72:  GOTO   62A
....................                   { 
....................                      //calculo de grados centigrados 
....................                      centigrados = (temperatura - 32)/faCentigrados; 
0D73:  BSF    03.1
0D74:  MOVF   34,W
0D75:  MOVWF  64
0D76:  MOVF   33,W
0D77:  MOVWF  63
0D78:  MOVF   32,W
0D79:  MOVWF  62
0D7A:  MOVF   31,W
0D7B:  MOVWF  61
0D7C:  CLRF   68
0D7D:  CLRF   67
0D7E:  CLRF   66
0D7F:  MOVLW  84
0D80:  MOVWF  65
0D81:  BCF    0A.3
0D82:  CALL   44E
0D83:  BSF    0A.3
0D84:  MOVF   7A,W
0D85:  MOVWF  42
0D86:  MOVF   79,W
0D87:  MOVWF  41
0D88:  MOVF   78,W
0D89:  MOVWF  40
0D8A:  MOVF   77,W
0D8B:  MOVWF  3F
0D8C:  MOVF   7A,W
0D8D:  MOVWF  64
0D8E:  MOVF   79,W
0D8F:  MOVWF  63
0D90:  MOVF   78,W
0D91:  MOVWF  62
0D92:  MOVF   77,W
0D93:  MOVWF  61
0D94:  MOVLW  66
0D95:  MOVWF  68
0D96:  MOVWF  67
0D97:  MOVWF  66
0D98:  MOVLW  7F
0D99:  MOVWF  65
0D9A:  BCF    0A.3
0D9B:  CALL   384
0D9C:  BSF    0A.3
0D9D:  MOVF   7A,W
0D9E:  MOVWF  38
0D9F:  MOVF   79,W
0DA0:  MOVWF  37
0DA1:  MOVF   78,W
0DA2:  MOVWF  36
0DA3:  MOVF   77,W
0DA4:  MOVWF  35
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0DA5:  MOVLW  01
0DA6:  MOVWF  4D
0DA7:  MOVLW  02
0DA8:  MOVWF  4E
0DA9:  BCF    0A.3
0DAA:  CALL   1AD
0DAB:  BSF    0A.3
....................                      printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0DAC:  MOVLW  54
0DAD:  MOVWF  4C
0DAE:  BCF    0A.3
0DAF:  CALL   1BF
0DB0:  BSF    0A.3
0DB1:  MOVLW  3A
0DB2:  MOVWF  4C
0DB3:  BCF    0A.3
0DB4:  CALL   1BF
0DB5:  BSF    0A.3
0DB6:  MOVLW  20
0DB7:  MOVWF  4C
0DB8:  BCF    0A.3
0DB9:  CALL   1BF
0DBA:  BSF    0A.3
0DBB:  MOVLW  89
0DBC:  MOVWF  04
0DBD:  MOVF   38,W
0DBE:  MOVWF  42
0DBF:  MOVF   37,W
0DC0:  MOVWF  41
0DC1:  MOVF   36,W
0DC2:  MOVWF  40
0DC3:  MOVF   35,W
0DC4:  MOVWF  3F
0DC5:  MOVLW  01
0DC6:  MOVWF  43
0DC7:  CALL   000
0DC8:  MOVLW  20
0DC9:  MOVWF  4C
0DCA:  BCF    0A.3
0DCB:  CALL   1BF
0DCC:  BSF    0A.3
0DCD:  MOVLW  DF
0DCE:  MOVWF  4C
0DCF:  BCF    0A.3
0DD0:  CALL   1BF
0DD1:  BSF    0A.3
0DD2:  MOVLW  43
0DD3:  MOVWF  4C
0DD4:  BCF    0A.3
0DD5:  CALL   1BF
0DD6:  BSF    0A.3
....................                      printf("Temperatura (C): %.1f (C)   |   Puerta: %u   |   Ventilador: OFF\n\r",centigrados, puerta); 
0DD7:  MOVLW  A5
0DD8:  BSF    03.6
0DD9:  MOVWF  0D
0DDA:  MOVLW  00
0DDB:  MOVWF  0F
0DDC:  BCF    03.0
0DDD:  MOVLW  11
0DDE:  BCF    03.6
0DDF:  MOVWF  3F
0DE0:  CALL   0D3
0DE1:  MOVLW  89
0DE2:  MOVWF  04
0DE3:  MOVF   38,W
0DE4:  MOVWF  42
0DE5:  MOVF   37,W
0DE6:  MOVWF  41
0DE7:  MOVF   36,W
0DE8:  MOVWF  40
0DE9:  MOVF   35,W
0DEA:  MOVWF  3F
0DEB:  MOVLW  01
0DEC:  MOVWF  43
0DED:  CALL   12C
0DEE:  MOVLW  AF
0DEF:  BSF    03.6
0DF0:  MOVWF  0D
0DF1:  MOVLW  00
0DF2:  MOVWF  0F
0DF3:  BSF    03.0
0DF4:  MOVLW  13
0DF5:  BCF    03.6
0DF6:  MOVWF  3F
0DF7:  CALL   0D3
0DF8:  MOVF   2F,W
0DF9:  MOVWF  3F
0DFA:  MOVLW  1B
0DFB:  MOVWF  40
0DFC:  CALL   1FB
0DFD:  MOVLW  BA
0DFE:  BSF    03.6
0DFF:  MOVWF  0D
0E00:  MOVLW  00
0E01:  MOVWF  0F
0E02:  BCF    03.0
0E03:  MOVLW  18
0E04:  BCF    03.6
0E05:  MOVWF  3F
0E06:  CALL   0D3
....................                      //ventilador 
....................                      output_low(PIN_C1); 
0E07:  BCF    2E.1
0E08:  MOVF   2E,W
0E09:  BSF    03.5
0E0A:  MOVWF  07
0E0B:  BCF    03.5
0E0C:  BCF    07.1
....................                      output_low(PIN_C2); 
0E0D:  BCF    2E.2
0E0E:  MOVF   2E,W
0E0F:  BSF    03.5
0E10:  MOVWF  07
0E11:  BCF    03.5
0E12:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0E13:  MOVLW  0C
0E14:  MOVWF  4D
0E15:  MOVLW  02
0E16:  MOVWF  4E
0E17:  BCF    0A.3
0E18:  CALL   1AD
0E19:  BSF    0A.3
....................                      printf(lcd_putc, "V:OFF"); 
0E1A:  MOVLW  C7
0E1B:  BSF    03.6
0E1C:  MOVWF  0D
0E1D:  MOVLW  00
0E1E:  MOVWF  0F
0E1F:  BCF    0A.3
0E20:  BCF    03.6
0E21:  CALL   1EB
0E22:  BSF    0A.3
....................                      //led 
....................                      output_low(PIN_C0); 
0E23:  BCF    2E.0
0E24:  MOVF   2E,W
0E25:  BSF    03.5
0E26:  MOVWF  07
0E27:  BCF    03.5
0E28:  BCF    07.0
....................                       
....................                       
....................                   }else{ 
0E29:  GOTO   641
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0E2A:  MOVLW  01
0E2B:  MOVWF  4D
0E2C:  MOVLW  02
0E2D:  MOVWF  4E
0E2E:  BCF    0A.3
0E2F:  CALL   1AD
0E30:  BSF    0A.3
....................                      printf(lcd_putc, "T:NA"); 
0E31:  MOVLW  CA
0E32:  BSF    03.6
0E33:  MOVWF  0D
0E34:  MOVLW  00
0E35:  MOVWF  0F
0E36:  BCF    0A.3
0E37:  BCF    03.6
0E38:  CALL   1EB
0E39:  BSF    0A.3
....................                      printf("DESCONECTADO\n\r"); 
0E3A:  MOVLW  CD
0E3B:  BSF    03.6
0E3C:  MOVWF  0D
0E3D:  MOVLW  00
0E3E:  MOVWF  0F
0E3F:  BCF    03.6
0E40:  CALL   237
....................                   } 
....................                    
....................                   //encender o salir 
....................                   salir = getch(); 
0E41:  BCF    0A.3
0E42:  CALL   241
0E43:  BSF    0A.3
0E44:  MOVF   78,W
0E45:  MOVWF  3E
....................                   if(salir == 'c' || salir == 's') 
0E46:  MOVF   3E,W
0E47:  SUBLW  63
0E48:  BTFSC  03.2
0E49:  GOTO   64D
0E4A:  MOVF   3E,W
0E4B:  SUBLW  73
0E4C:  BTFSC  03.2
....................                   { 
....................                      break; 
0E4D:  GOTO   658
....................                   } 
....................                   delay_ms(1500); 
0E4E:  MOVLW  06
0E4F:  MOVWF  3F
0E50:  MOVLW  FA
0E51:  MOVWF  4D
0E52:  BCF    0A.3
0E53:  CALL   108
0E54:  BSF    0A.3
0E55:  DECFSZ 3F,F
0E56:  GOTO   650
0E57:  GOTO   54C
....................                    
....................                } 
....................                if(salir == 's'){ 
0E58:  MOVF   3E,W
0E59:  SUBLW  73
0E5A:  BTFSC  03.2
....................                   break; 
0E5B:  GOTO   76D
....................                } 
....................                while(true) 
....................                { 
....................                    
....................                    
....................                    
....................                   //Normalmente encendido 
....................                    
....................                   //lectura de temperatura 
....................                   data_ok = DHT11_read_data(&temperatura,&humedad); 
0E5C:  CLRF   40
0E5D:  MOVLW  31
0E5E:  MOVWF  3F
0E5F:  CLRF   42
0E60:  MOVLW  39
0E61:  MOVWF  41
0E62:  BCF    0A.3
0E63:  CALL   6B1
0E64:  BSF    0A.3
0E65:  MOVF   78,W
0E66:  MOVWF  30
....................                   //lectura de puerta 
....................                   puerta = input(spuerta); 
0E67:  BSF    03.5
0E68:  BSF    05.1
0E69:  BCF    03.5
0E6A:  CLRF   2F
0E6B:  BTFSC  05.1
0E6C:  INCF   2F,F
....................                   //Imprimir en LCD 
....................                   printf(lcd_putc, "\f"); 
0E6D:  MOVLW  0C
0E6E:  MOVWF  4C
0E6F:  BCF    0A.3
0E70:  CALL   1BF
0E71:  BSF    0A.3
....................                   lcd_gotoxy(1,1); 
0E72:  MOVLW  01
0E73:  MOVWF  4D
0E74:  MOVWF  4E
0E75:  BCF    0A.3
0E76:  CALL   1AD
0E77:  BSF    0A.3
....................                   printf(lcd_putc, "m:Manu"); 
0E78:  MOVLW  D5
0E79:  BSF    03.6
0E7A:  MOVWF  0D
0E7B:  MOVLW  00
0E7C:  MOVWF  0F
0E7D:  BCF    0A.3
0E7E:  BCF    03.6
0E7F:  CALL   1EB
0E80:  BSF    0A.3
....................                    
....................                   if(data_ok == 1) 
0E81:  DECFSZ 30,W
0E82:  GOTO   73A
....................                   { 
....................                      //calculo de grados centigrados 
....................                      centigrados = (temperatura - 32)/faCentigrados; 
0E83:  BSF    03.1
0E84:  MOVF   34,W
0E85:  MOVWF  64
0E86:  MOVF   33,W
0E87:  MOVWF  63
0E88:  MOVF   32,W
0E89:  MOVWF  62
0E8A:  MOVF   31,W
0E8B:  MOVWF  61
0E8C:  CLRF   68
0E8D:  CLRF   67
0E8E:  CLRF   66
0E8F:  MOVLW  84
0E90:  MOVWF  65
0E91:  BCF    0A.3
0E92:  CALL   44E
0E93:  BSF    0A.3
0E94:  MOVF   7A,W
0E95:  MOVWF  42
0E96:  MOVF   79,W
0E97:  MOVWF  41
0E98:  MOVF   78,W
0E99:  MOVWF  40
0E9A:  MOVF   77,W
0E9B:  MOVWF  3F
0E9C:  MOVF   7A,W
0E9D:  MOVWF  64
0E9E:  MOVF   79,W
0E9F:  MOVWF  63
0EA0:  MOVF   78,W
0EA1:  MOVWF  62
0EA2:  MOVF   77,W
0EA3:  MOVWF  61
0EA4:  MOVLW  66
0EA5:  MOVWF  68
0EA6:  MOVWF  67
0EA7:  MOVWF  66
0EA8:  MOVLW  7F
0EA9:  MOVWF  65
0EAA:  BCF    0A.3
0EAB:  CALL   384
0EAC:  BSF    0A.3
0EAD:  MOVF   7A,W
0EAE:  MOVWF  38
0EAF:  MOVF   79,W
0EB0:  MOVWF  37
0EB1:  MOVF   78,W
0EB2:  MOVWF  36
0EB3:  MOVF   77,W
0EB4:  MOVWF  35
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0EB5:  MOVLW  01
0EB6:  MOVWF  4D
0EB7:  MOVLW  02
0EB8:  MOVWF  4E
0EB9:  BCF    0A.3
0EBA:  CALL   1AD
0EBB:  BSF    0A.3
....................                      printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0EBC:  MOVLW  54
0EBD:  MOVWF  4C
0EBE:  BCF    0A.3
0EBF:  CALL   1BF
0EC0:  BSF    0A.3
0EC1:  MOVLW  3A
0EC2:  MOVWF  4C
0EC3:  BCF    0A.3
0EC4:  CALL   1BF
0EC5:  BSF    0A.3
0EC6:  MOVLW  20
0EC7:  MOVWF  4C
0EC8:  BCF    0A.3
0EC9:  CALL   1BF
0ECA:  BSF    0A.3
0ECB:  MOVLW  89
0ECC:  MOVWF  04
0ECD:  MOVF   38,W
0ECE:  MOVWF  42
0ECF:  MOVF   37,W
0ED0:  MOVWF  41
0ED1:  MOVF   36,W
0ED2:  MOVWF  40
0ED3:  MOVF   35,W
0ED4:  MOVWF  3F
0ED5:  MOVLW  01
0ED6:  MOVWF  43
0ED7:  CALL   000
0ED8:  MOVLW  20
0ED9:  MOVWF  4C
0EDA:  BCF    0A.3
0EDB:  CALL   1BF
0EDC:  BSF    0A.3
0EDD:  MOVLW  DF
0EDE:  MOVWF  4C
0EDF:  BCF    0A.3
0EE0:  CALL   1BF
0EE1:  BSF    0A.3
0EE2:  MOVLW  43
0EE3:  MOVWF  4C
0EE4:  BCF    0A.3
0EE5:  CALL   1BF
0EE6:  BSF    0A.3
....................                      printf("Temperatura (C): %.1f (C)  |   Puerta: %u   |   Ventilador: ON\n\r",centigrados, puerta); 
0EE7:  MOVLW  D9
0EE8:  BSF    03.6
0EE9:  MOVWF  0D
0EEA:  MOVLW  00
0EEB:  MOVWF  0F
0EEC:  BCF    03.0
0EED:  MOVLW  11
0EEE:  BCF    03.6
0EEF:  MOVWF  3F
0EF0:  CALL   0D3
0EF1:  MOVLW  89
0EF2:  MOVWF  04
0EF3:  MOVF   38,W
0EF4:  MOVWF  42
0EF5:  MOVF   37,W
0EF6:  MOVWF  41
0EF7:  MOVF   36,W
0EF8:  MOVWF  40
0EF9:  MOVF   35,W
0EFA:  MOVWF  3F
0EFB:  MOVLW  01
0EFC:  MOVWF  43
0EFD:  CALL   12C
0EFE:  MOVLW  E3
0EFF:  BSF    03.6
0F00:  MOVWF  0D
0F01:  MOVLW  00
0F02:  MOVWF  0F
0F03:  BSF    03.0
0F04:  MOVLW  12
0F05:  BCF    03.6
0F06:  MOVWF  3F
0F07:  CALL   0D3
0F08:  MOVF   2F,W
0F09:  MOVWF  3F
0F0A:  MOVLW  1B
0F0B:  MOVWF  40
0F0C:  CALL   1FB
0F0D:  MOVLW  ED
0F0E:  BSF    03.6
0F0F:  MOVWF  0D
0F10:  MOVLW  00
0F11:  MOVWF  0F
0F12:  BSF    03.0
0F13:  MOVLW  17
0F14:  BCF    03.6
0F15:  MOVWF  3F
0F16:  CALL   0D3
....................                      //ventilador 
....................                      output_high(PIN_C1); 
0F17:  BCF    2E.1
0F18:  MOVF   2E,W
0F19:  BSF    03.5
0F1A:  MOVWF  07
0F1B:  BCF    03.5
0F1C:  BSF    07.1
....................                      output_low(PIN_C2); 
0F1D:  BCF    2E.2
0F1E:  MOVF   2E,W
0F1F:  BSF    03.5
0F20:  MOVWF  07
0F21:  BCF    03.5
0F22:  BCF    07.2
....................                      //led 
....................                      output_high(PIN_C0); 
0F23:  BCF    2E.0
0F24:  MOVF   2E,W
0F25:  BSF    03.5
0F26:  MOVWF  07
0F27:  BCF    03.5
0F28:  BSF    07.0
....................                      lcd_gotoxy(12,2); 
0F29:  MOVLW  0C
0F2A:  MOVWF  4D
0F2B:  MOVLW  02
0F2C:  MOVWF  4E
0F2D:  BCF    0A.3
0F2E:  CALL   1AD
0F2F:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0F30:  MOVLW  FA
0F31:  BSF    03.6
0F32:  MOVWF  0D
0F33:  MOVLW  00
0F34:  MOVWF  0F
0F35:  BCF    0A.3
0F36:  BCF    03.6
0F37:  CALL   1EB
0F38:  BSF    0A.3
....................                       
....................                       
....................                   }else{ 
0F39:  GOTO   751
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0F3A:  MOVLW  01
0F3B:  MOVWF  4D
0F3C:  MOVLW  02
0F3D:  MOVWF  4E
0F3E:  BCF    0A.3
0F3F:  CALL   1AD
0F40:  BSF    0A.3
....................                      printf(lcd_putc, "T:NA"); 
0F41:  MOVLW  FD
0F42:  BSF    03.6
0F43:  MOVWF  0D
0F44:  MOVLW  00
0F45:  MOVWF  0F
0F46:  BCF    0A.3
0F47:  BCF    03.6
0F48:  CALL   1EB
0F49:  BSF    0A.3
....................                      printf("DESCONECTADO\n\r"); 
0F4A:  MOVLW  00
0F4B:  BSF    03.6
0F4C:  MOVWF  0D
0F4D:  MOVLW  01
0F4E:  MOVWF  0F
0F4F:  BCF    03.6
0F50:  CALL   237
....................                   } 
....................                    
....................                    
....................                    
....................                    
....................                    
....................                   //apagar o salir 
....................                   salir = getch(); 
0F51:  BCF    0A.3
0F52:  CALL   241
0F53:  BSF    0A.3
0F54:  MOVF   78,W
0F55:  MOVWF  3E
....................                   if(salir == 'c' || salir == 's') 
0F56:  MOVF   3E,W
0F57:  SUBLW  63
0F58:  BTFSC  03.2
0F59:  GOTO   75D
0F5A:  MOVF   3E,W
0F5B:  SUBLW  73
0F5C:  BTFSC  03.2
....................                   { 
....................                      break; 
0F5D:  GOTO   768
....................                   } 
....................                   delay_ms(1500); 
0F5E:  MOVLW  06
0F5F:  MOVWF  3F
0F60:  MOVLW  FA
0F61:  MOVWF  4D
0F62:  BCF    0A.3
0F63:  CALL   108
0F64:  BSF    0A.3
0F65:  DECFSZ 3F,F
0F66:  GOTO   760
0F67:  GOTO   65C
....................                } 
....................                if(salir == 's'){ 
0F68:  MOVF   3E,W
0F69:  SUBLW  73
0F6A:  BTFSC  03.2
....................                   break; 
0F6B:  GOTO   76D
....................                } 
0F6C:  GOTO   54C
....................                 
....................             } 
....................                 
....................              
....................                       
....................           
....................           
....................          } 
....................                 
....................       } 
0F6D:  GOTO   2D1
....................        
....................        
....................       
....................        
....................        
....................       
....................    } 
.................... } 
0F6E:  SLEEP

Configuration Fuses:
   Word  1: 2CA4   INTRC_IO NOWDT PUT MCLR PROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
