CCS PCM C Compiler, Version 5.015, 5967               03-Dec-23 02:07

               Filename:   C:\Users\soyan\proyectos_programacion\7_MM\pf\pf.lst

               ROM used:   3993 words (49%)
                           Largest free fragment is 2048
               RAM used:   40 (11%) at main() level
                           86 (23%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   28F
0003:  NOP
.................... #include<16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 0C,29
0005:  DATA E5,30
0006:  DATA E4,3C
0007:  DATA 2E,17
0008:  DATA 2E,05
0009:  DATA 00,00
000A:  DATA D3,32
000B:  DATA EC,32
000C:  DATA E3,31
000D:  DATA E9,37
000E:  DATA 6E,10
000F:  DATA ED,37
0010:  DATA E4,37
0011:  DATA 00,01
0012:  DATA 61,1D
0013:  DATA C1,3A
0014:  DATA F4,37
0015:  DATA 20,3E
0016:  DATA 20,31
0017:  DATA BA,26
0018:  DATA 61,37
0019:  DATA 00,01
001A:  DATA 6D,1D
001B:  DATA C1,3A
001C:  DATA F4,37
001D:  DATA 00,01
001E:  DATA D0,3A
001F:  DATA 65,1D
0020:  DATA 43,36
0021:  DATA 6F,05
0022:  DATA 0D,00
0023:  DATA D0,3A
0024:  DATA 65,1D
0025:  DATA 4F,38
0026:  DATA 65,00
0027:  DATA 56,1D
0028:  DATA 4F,27
0029:  DATA 00,01
002A:  DATA D4,32
002B:  DATA 6D,38
002C:  DATA 65,39
002D:  DATA 61,3A
002E:  DATA 75,39
002F:  DATA 61,10
0030:  DATA A8,21
0031:  DATA 29,1D
0032:  DATA A0,12
0033:  DATA AE,18
0034:  DATA 66,10
0035:  DATA A5,31
0036:  DATA 20,10
0037:  DATA 20,3E
0038:  DATA 20,10
0039:  DATA 20,28
003A:  DATA F5,32
003B:  DATA 72,3A
003C:  DATA 61,1D
003D:  DATA A0,12
003E:  DATA 75,10
003F:  DATA 20,10
0040:  DATA 7C,10
0041:  DATA 20,10
0042:  DATA D6,32
0043:  DATA 6E,3A
0044:  DATA 69,36
0045:  DATA 61,32
0046:  DATA 6F,39
0047:  DATA 3A,10
0048:  DATA 4F,27
0049:  DATA 8A,06
004A:  DATA 00,00
004B:  DATA 56,1D
004C:  DATA 4F,27
004D:  DATA 00,01
004E:  DATA D4,32
004F:  DATA 6D,38
0050:  DATA 65,39
0051:  DATA 61,3A
0052:  DATA 75,39
0053:  DATA 61,10
0054:  DATA A8,21
0055:  DATA 29,1D
0056:  DATA A0,12
0057:  DATA AE,18
0058:  DATA 66,10
0059:  DATA A5,31
005A:  DATA 28,28
005B:  DATA F2,32
005C:  DATA E3,30
005D:  DATA F5,31
005E:  DATA E9,37
005F:  DATA EE,14
0060:  DATA 7C,28
0061:  DATA F5,32
0062:  DATA 72,3A
0063:  DATA 61,1D
0064:  DATA A0,12
0065:  DATA 75,3E
0066:  DATA D6,32
0067:  DATA 6E,3A
0068:  DATA 69,36
0069:  DATA 61,32
006A:  DATA 6F,39
006B:  DATA 3A,10
006C:  DATA 4F,27
006D:  DATA 8A,06
006E:  DATA 00,01
006F:  DATA 56,1D
0070:  DATA 4F,23
0071:  DATA 46,00
0072:  DATA D4,32
0073:  DATA 6D,38
0074:  DATA 65,39
0075:  DATA 61,3A
0076:  DATA 75,39
0077:  DATA 61,10
0078:  DATA A8,21
0079:  DATA 29,1D
007A:  DATA A0,12
007B:  DATA AE,18
007C:  DATA 66,10
007D:  DATA A5,31
007E:  DATA 20,10
007F:  DATA 20,3E
0080:  DATA 20,10
0081:  DATA 20,28
0082:  DATA F5,32
0083:  DATA 72,3A
0084:  DATA 61,1D
0085:  DATA A0,12
0086:  DATA 75,10
0087:  DATA 20,10
0088:  DATA 7C,10
0089:  DATA 20,10
008A:  DATA D6,32
008B:  DATA 6E,3A
008C:  DATA 69,36
008D:  DATA 61,32
008E:  DATA 6F,39
008F:  DATA 3A,10
0090:  DATA 4F,23
0091:  DATA 46,05
0092:  DATA 0D,00
0093:  DATA 54,1D
0094:  DATA CE,20
0095:  DATA 00,01
0096:  DATA C4,22
0097:  DATA D3,21
0098:  DATA 4F,27
0099:  DATA C5,21
009A:  DATA D4,20
009B:  DATA C4,27
009C:  DATA 8A,06
009D:  DATA 00,00
009E:  DATA 6D,1D
009F:  DATA CD,30
00A0:  DATA EE,3A
00A1:  DATA 00,01
00A2:  DATA D4,32
00A3:  DATA 6D,38
00A4:  DATA 65,39
00A5:  DATA 61,3A
00A6:  DATA 75,39
00A7:  DATA 61,10
00A8:  DATA A8,21
00A9:  DATA 29,1D
00AA:  DATA A0,12
00AB:  DATA AE,18
00AC:  DATA 66,10
00AD:  DATA A5,31
00AE:  DATA 20,10
00AF:  DATA 20,3E
00B0:  DATA 20,10
00B1:  DATA 20,28
00B2:  DATA F5,32
00B3:  DATA 72,3A
00B4:  DATA 61,1D
00B5:  DATA A0,12
00B6:  DATA 75,10
00B7:  DATA 20,10
00B8:  DATA 7C,10
00B9:  DATA 20,10
00BA:  DATA D6,32
00BB:  DATA 6E,3A
00BC:  DATA 69,36
00BD:  DATA 61,32
00BE:  DATA 6F,39
00BF:  DATA 3A,10
00C0:  DATA 4F,23
00C1:  DATA 46,05
00C2:  DATA 0D,00
00C3:  DATA 56,1D
00C4:  DATA 4F,23
00C5:  DATA 46,00
00C6:  DATA 54,1D
00C7:  DATA CE,20
00C8:  DATA 00,01
00C9:  DATA C4,22
00CA:  DATA D3,21
00CB:  DATA 4F,27
00CC:  DATA C5,21
00CD:  DATA D4,20
00CE:  DATA C4,27
00CF:  DATA 8A,06
00D0:  DATA 00,01
00D1:  DATA 6D,1D
00D2:  DATA CD,30
00D3:  DATA EE,3A
00D4:  DATA 00,01
00D5:  DATA D4,32
00D6:  DATA 6D,38
00D7:  DATA 65,39
00D8:  DATA 61,3A
00D9:  DATA 75,39
00DA:  DATA 61,10
00DB:  DATA A8,21
00DC:  DATA 29,1D
00DD:  DATA A0,12
00DE:  DATA AE,18
00DF:  DATA 66,10
00E0:  DATA A5,31
00E1:  DATA 20,10
00E2:  DATA 20,3E
00E3:  DATA 20,10
00E4:  DATA 20,28
00E5:  DATA F5,32
00E6:  DATA 72,3A
00E7:  DATA 61,1D
00E8:  DATA A0,12
00E9:  DATA 75,10
00EA:  DATA 20,10
00EB:  DATA 7C,10
00EC:  DATA 20,10
00ED:  DATA D6,32
00EE:  DATA 6E,3A
00EF:  DATA 69,36
00F0:  DATA 61,32
00F1:  DATA 6F,39
00F2:  DATA 3A,10
00F3:  DATA 4F,27
00F4:  DATA 8A,06
00F5:  DATA 00,01
00F6:  DATA 56,1D
00F7:  DATA 4F,27
00F8:  DATA 00,01
00F9:  DATA 54,1D
00FA:  DATA CE,20
00FB:  DATA 00,01
00FC:  DATA C4,22
00FD:  DATA D3,21
00FE:  DATA 4F,27
00FF:  DATA C5,21
0100:  DATA D4,20
0101:  DATA C4,27
0102:  DATA 8A,06
0103:  DATA 00,00
*
01E7:  MOVF   0B,W
01E8:  MOVWF  3F
01E9:  BCF    0B.7
01EA:  BSF    03.5
01EB:  BSF    03.6
01EC:  BSF    0C.7
01ED:  BSF    0C.0
01EE:  NOP
01EF:  NOP
01F0:  BCF    03.5
01F1:  BCF    03.6
01F2:  BTFSC  3F.7
01F3:  BSF    0B.7
01F4:  BSF    03.6
01F5:  MOVF   0C,W
01F6:  ANDLW  7F
01F7:  BTFSC  03.2
01F8:  GOTO   23B
01F9:  BCF    03.6
01FA:  MOVWF  3F
01FB:  BSF    03.6
01FC:  MOVF   0D,W
01FD:  BCF    03.6
01FE:  MOVWF  40
01FF:  BSF    03.6
0200:  MOVF   0F,W
0201:  BCF    03.6
0202:  MOVWF  41
0203:  MOVF   3F,W
0204:  MOVWF  4C
0205:  CALL   1BB
0206:  MOVF   40,W
0207:  BSF    03.6
0208:  MOVWF  0D
0209:  BCF    03.6
020A:  MOVF   41,W
020B:  BSF    03.6
020C:  MOVWF  0F
020D:  BCF    03.6
020E:  MOVF   0B,W
020F:  MOVWF  42
0210:  BCF    0B.7
0211:  BSF    03.5
0212:  BSF    03.6
0213:  BSF    0C.7
0214:  BSF    0C.0
0215:  NOP
0216:  NOP
0217:  BCF    03.5
0218:  BCF    03.6
0219:  BTFSC  42.7
021A:  BSF    0B.7
021B:  BSF    03.6
021C:  RLF    0C,W
021D:  RLF    0E,W
021E:  ANDLW  7F
021F:  BTFSC  03.2
0220:  GOTO   23B
0221:  BCF    03.6
0222:  MOVWF  3F
0223:  BSF    03.6
0224:  MOVF   0D,W
0225:  BCF    03.6
0226:  MOVWF  40
0227:  BSF    03.6
0228:  MOVF   0F,W
0229:  BCF    03.6
022A:  MOVWF  41
022B:  MOVF   3F,W
022C:  MOVWF  4C
022D:  CALL   1BB
022E:  MOVF   40,W
022F:  BSF    03.6
0230:  MOVWF  0D
0231:  BCF    03.6
0232:  MOVF   41,W
0233:  BSF    03.6
0234:  MOVWF  0F
0235:  INCF   0D,F
0236:  BTFSC  03.2
0237:  INCF   0F,F
0238:  BCF    03.6
0239:  GOTO   1E7
023A:  BSF    03.6
023B:  BCF    03.6
023C:  RETURN
*
0275:  MOVF   53,W
0276:  CLRF   78
0277:  SUBWF  52,W
0278:  BTFSC  03.0
0279:  GOTO   27D
027A:  MOVF   52,W
027B:  MOVWF  77
027C:  GOTO   289
027D:  CLRF   77
027E:  MOVLW  08
027F:  MOVWF  54
0280:  RLF    52,F
0281:  RLF    77,F
0282:  MOVF   53,W
0283:  SUBWF  77,W
0284:  BTFSC  03.0
0285:  MOVWF  77
0286:  RLF    78,F
0287:  DECFSZ 54,F
0288:  GOTO   280
0289:  RETURN
028A:  MOVF   2C,W
028B:  MOVWF  04
028C:  BCF    03.7
028D:  BTFSC  2D.0
028E:  BSF    03.7
028F:  MOVF   52,W
0290:  MOVWF  00
0291:  INCF   04,F
0292:  CLRF   00
0293:  INCF   2C,F
0294:  BTFSC  03.2
0295:  INCF   2D,F
0296:  RETURN
0297:  MOVLW  20
0298:  BTFSS  4D.4
0299:  MOVLW  30
029A:  MOVWF  4E
029B:  MOVF   4C,W
029C:  MOVWF  77
029D:  BTFSS  4C.7
029E:  GOTO   2A7
029F:  COMF   77,F
02A0:  INCF   77,F
02A1:  MOVF   77,W
02A2:  MOVWF  4C
02A3:  MOVLW  2D
02A4:  MOVWF  4E
02A5:  BSF    4D.7
02A6:  BSF    4D.0
02A7:  MOVF   4C,W
02A8:  MOVWF  52
02A9:  MOVLW  64
02AA:  MOVWF  53
02AB:  CALL   275
02AC:  MOVF   77,W
02AD:  MOVWF  4C
02AE:  MOVLW  30
02AF:  ADDWF  78,W
02B0:  MOVWF  4F
02B1:  MOVF   4C,W
02B2:  MOVWF  52
02B3:  MOVLW  0A
02B4:  MOVWF  53
02B5:  CALL   275
02B6:  MOVLW  30
02B7:  ADDWF  77,W
02B8:  MOVWF  51
02B9:  MOVLW  30
02BA:  ADDWF  78,W
02BB:  MOVWF  50
02BC:  MOVF   4E,W
02BD:  MOVWF  77
02BE:  MOVLW  30
02BF:  SUBWF  4F,W
02C0:  BTFSC  03.2
02C1:  GOTO   2C6
02C2:  BSF    4D.1
02C3:  BTFSC  4D.7
02C4:  BSF    4D.2
02C5:  GOTO   2DA
02C6:  MOVF   4E,W
02C7:  MOVWF  4F
02C8:  MOVLW  20
02C9:  MOVWF  4E
02CA:  MOVLW  30
02CB:  SUBWF  50,W
02CC:  BTFSC  03.2
02CD:  GOTO   2D2
02CE:  BSF    4D.0
02CF:  BTFSC  4D.7
02D0:  BSF    4D.1
02D1:  GOTO   2DA
02D2:  BTFSS  03.2
02D3:  BSF    4D.0
02D4:  BTFSS  03.2
02D5:  GOTO   2DA
02D6:  MOVF   4F,W
02D7:  MOVWF  50
02D8:  MOVLW  20
02D9:  MOVWF  4F
02DA:  BTFSC  4D.2
02DB:  GOTO   2E1
02DC:  BTFSC  4D.1
02DD:  GOTO   2E4
02DE:  BTFSC  4D.0
02DF:  GOTO   2E7
02E0:  GOTO   2EA
02E1:  MOVF   4E,W
02E2:  MOVWF  52
02E3:  CALL   28A
02E4:  MOVF   4F,W
02E5:  MOVWF  52
02E6:  CALL   28A
02E7:  MOVF   50,W
02E8:  MOVWF  52
02E9:  CALL   28A
02EA:  MOVF   51,W
02EB:  MOVWF  52
02EC:  CALL   28A
02ED:  RETURN
02EE:  MOVF   5D,W
02EF:  BTFSC  03.2
02F0:  GOTO   35E
02F1:  MOVWF  65
02F2:  MOVF   61,W
02F3:  BTFSC  03.2
02F4:  GOTO   35E
02F5:  ADDWF  65,F
02F6:  BTFSC  03.0
02F7:  GOTO   2FF
02F8:  MOVLW  7F
02F9:  SUBWF  65,F
02FA:  BTFSS  03.0
02FB:  GOTO   35E
02FC:  BTFSC  03.2
02FD:  GOTO   35E
02FE:  GOTO   303
02FF:  MOVLW  81
0300:  ADDWF  65,F
0301:  BTFSC  03.0
0302:  GOTO   35E
0303:  MOVF   65,W
0304:  MOVWF  77
0305:  CLRF   78
0306:  CLRF   79
0307:  CLRF   7A
0308:  MOVF   5E,W
0309:  MOVWF  69
030A:  BSF    69.7
030B:  MOVF   5F,W
030C:  MOVWF  68
030D:  MOVF   60,W
030E:  MOVWF  67
030F:  MOVLW  18
0310:  MOVWF  65
0311:  CLRF   66
0312:  BTFSS  67.0
0313:  GOTO   32C
0314:  MOVF   64,W
0315:  ADDWF  7A,F
0316:  BTFSS  03.0
0317:  GOTO   31E
0318:  INCF   79,F
0319:  BTFSS  03.2
031A:  GOTO   31E
031B:  INCF   78,F
031C:  BTFSC  03.2
031D:  BSF    66.7
031E:  MOVF   63,W
031F:  ADDWF  79,F
0320:  BTFSS  03.0
0321:  GOTO   325
0322:  INCF   78,F
0323:  BTFSC  03.2
0324:  BSF    66.7
0325:  MOVF   62,W
0326:  MOVWF  5F
0327:  BSF    5F.7
0328:  MOVF   5F,W
0329:  ADDWF  78,F
032A:  BTFSC  03.0
032B:  BSF    66.7
032C:  RLF    66,F
032D:  RRF    78,F
032E:  RRF    79,F
032F:  RRF    7A,F
0330:  RRF    69,F
0331:  RRF    68,F
0332:  RRF    67,F
0333:  BCF    03.0
0334:  DECFSZ 65,F
0335:  GOTO   311
0336:  MOVLW  01
0337:  ADDWF  77,F
0338:  BTFSC  03.0
0339:  GOTO   35E
033A:  BTFSC  78.7
033B:  GOTO   343
033C:  RLF    69,F
033D:  RLF    7A,F
033E:  RLF    79,F
033F:  RLF    78,F
0340:  DECF   77,F
0341:  BTFSC  03.2
0342:  GOTO   35E
0343:  BTFSS  69.7
0344:  GOTO   354
0345:  INCF   7A,F
0346:  BTFSS  03.2
0347:  GOTO   354
0348:  INCF   79,F
0349:  BTFSS  03.2
034A:  GOTO   354
034B:  INCF   78,F
034C:  BTFSS  03.2
034D:  GOTO   354
034E:  RRF    78,F
034F:  RRF    79,F
0350:  RRF    7A,F
0351:  INCF   77,F
0352:  BTFSC  03.2
0353:  GOTO   35E
0354:  MOVF   5E,W
0355:  MOVWF  66
0356:  MOVF   62,W
0357:  XORWF  66,F
0358:  BTFSS  66.7
0359:  GOTO   35C
035A:  BSF    78.7
035B:  GOTO   362
035C:  BCF    78.7
035D:  GOTO   362
035E:  CLRF   77
035F:  CLRF   78
0360:  CLRF   79
0361:  CLRF   7A
0362:  RETURN
0363:  MOVLW  8E
0364:  MOVWF  77
0365:  MOVF   62,W
0366:  MOVWF  78
0367:  MOVF   61,W
0368:  MOVWF  79
0369:  CLRF   7A
036A:  MOVF   78,F
036B:  BTFSS  03.2
036C:  GOTO   377
036D:  MOVF   79,W
036E:  MOVWF  78
036F:  CLRF   79
0370:  MOVLW  08
0371:  SUBWF  77,F
0372:  MOVF   78,F
0373:  BTFSS  03.2
0374:  GOTO   377
0375:  CLRF   77
0376:  GOTO   37F
0377:  BCF    03.0
0378:  BTFSC  78.7
0379:  GOTO   37E
037A:  RLF    79,F
037B:  RLF    78,F
037C:  DECF   77,F
037D:  GOTO   377
037E:  BCF    78.7
037F:  RETURN
0380:  MOVLW  80
0381:  BTFSC  03.1
0382:  XORWF  66,F
0383:  CLRF   6B
0384:  CLRF   6C
0385:  MOVF   62,W
0386:  MOVWF  6A
0387:  MOVF   66,W
0388:  XORWF  6A,F
0389:  MOVF   61,W
038A:  BTFSC  03.2
038B:  GOTO   470
038C:  MOVWF  69
038D:  MOVWF  77
038E:  MOVF   65,W
038F:  BTFSC  03.2
0390:  GOTO   479
0391:  SUBWF  69,F
0392:  BTFSC  03.2
0393:  GOTO   415
0394:  BTFSS  03.0
0395:  GOTO   3D3
0396:  MOVF   66,W
0397:  MOVWF  6F
0398:  BSF    6F.7
0399:  MOVF   67,W
039A:  MOVWF  6E
039B:  MOVF   68,W
039C:  MOVWF  6D
039D:  CLRF   6C
039E:  BCF    03.0
039F:  RRF    6F,F
03A0:  RRF    6E,F
03A1:  RRF    6D,F
03A2:  RRF    6C,F
03A3:  DECFSZ 69,F
03A4:  GOTO   39D
03A5:  BTFSS  6A.7
03A6:  GOTO   3AA
03A7:  BSF    6B.0
03A8:  GOTO   48D
03A9:  BCF    6B.0
03AA:  BCF    69.0
03AB:  BSF    6B.4
03AC:  MOVLW  64
03AD:  MOVWF  04
03AE:  BCF    03.7
03AF:  GOTO   4A2
03B0:  BCF    6B.4
03B1:  BTFSC  6A.7
03B2:  GOTO   3BD
03B3:  BTFSS  69.0
03B4:  GOTO   3C8
03B5:  RRF    6F,F
03B6:  RRF    6E,F
03B7:  RRF    6D,F
03B8:  RRF    6C,F
03B9:  INCF   77,F
03BA:  BTFSC  03.2
03BB:  GOTO   488
03BC:  GOTO   3C8
03BD:  BTFSC  6F.7
03BE:  GOTO   3CB
03BF:  BCF    03.0
03C0:  RLF    6C,F
03C1:  RLF    6D,F
03C2:  RLF    6E,F
03C3:  RLF    6F,F
03C4:  DECF   77,F
03C5:  BTFSC  03.2
03C6:  GOTO   488
03C7:  GOTO   3BD
03C8:  BSF    6B.6
03C9:  GOTO   435
03CA:  BCF    6B.6
03CB:  MOVF   62,W
03CC:  MOVWF  6A
03CD:  BTFSS  6A.7
03CE:  GOTO   3D1
03CF:  BSF    6F.7
03D0:  GOTO   481
03D1:  BCF    6F.7
03D2:  GOTO   481
03D3:  MOVF   65,W
03D4:  MOVWF  69
03D5:  MOVWF  77
03D6:  MOVF   61,W
03D7:  SUBWF  69,F
03D8:  MOVF   62,W
03D9:  MOVWF  6F
03DA:  BSF    6F.7
03DB:  MOVF   63,W
03DC:  MOVWF  6E
03DD:  MOVF   64,W
03DE:  MOVWF  6D
03DF:  CLRF   6C
03E0:  BCF    03.0
03E1:  RRF    6F,F
03E2:  RRF    6E,F
03E3:  RRF    6D,F
03E4:  RRF    6C,F
03E5:  DECFSZ 69,F
03E6:  GOTO   3DF
03E7:  BTFSS  6A.7
03E8:  GOTO   3EC
03E9:  BSF    6B.1
03EA:  GOTO   48D
03EB:  BCF    6B.1
03EC:  BCF    69.0
03ED:  BSF    6B.5
03EE:  MOVLW  68
03EF:  MOVWF  04
03F0:  BCF    03.7
03F1:  GOTO   4A2
03F2:  BCF    6B.5
03F3:  BTFSC  6A.7
03F4:  GOTO   3FF
03F5:  BTFSS  69.0
03F6:  GOTO   40A
03F7:  RRF    6F,F
03F8:  RRF    6E,F
03F9:  RRF    6D,F
03FA:  RRF    6C,F
03FB:  INCF   77,F
03FC:  BTFSC  03.2
03FD:  GOTO   488
03FE:  GOTO   40A
03FF:  BTFSC  6F.7
0400:  GOTO   40D
0401:  BCF    03.0
0402:  RLF    6C,F
0403:  RLF    6D,F
0404:  RLF    6E,F
0405:  RLF    6F,F
0406:  DECF   77,F
0407:  BTFSC  03.2
0408:  GOTO   488
0409:  GOTO   3FF
040A:  BSF    6B.7
040B:  GOTO   435
040C:  BCF    6B.7
040D:  MOVF   66,W
040E:  MOVWF  6A
040F:  BTFSS  6A.7
0410:  GOTO   413
0411:  BSF    6F.7
0412:  GOTO   481
0413:  BCF    6F.7
0414:  GOTO   481
0415:  MOVF   66,W
0416:  MOVWF  6F
0417:  BSF    6F.7
0418:  MOVF   67,W
0419:  MOVWF  6E
041A:  MOVF   68,W
041B:  MOVWF  6D
041C:  BTFSS  6A.7
041D:  GOTO   422
041E:  BCF    6F.7
041F:  BSF    6B.2
0420:  GOTO   48D
0421:  BCF    6B.2
0422:  CLRF   6C
0423:  BCF    69.0
0424:  MOVLW  64
0425:  MOVWF  04
0426:  BCF    03.7
0427:  GOTO   4A2
0428:  BTFSC  6A.7
0429:  GOTO   44B
042A:  MOVF   62,W
042B:  MOVWF  6A
042C:  BTFSS  69.0
042D:  GOTO   435
042E:  RRF    6F,F
042F:  RRF    6E,F
0430:  RRF    6D,F
0431:  RRF    6C,F
0432:  INCF   77,F
0433:  BTFSC  03.2
0434:  GOTO   488
0435:  BTFSS  6C.7
0436:  GOTO   446
0437:  INCF   6D,F
0438:  BTFSS  03.2
0439:  GOTO   446
043A:  INCF   6E,F
043B:  BTFSS  03.2
043C:  GOTO   446
043D:  INCF   6F,F
043E:  BTFSS  03.2
043F:  GOTO   446
0440:  RRF    6F,F
0441:  RRF    6E,F
0442:  RRF    6D,F
0443:  INCF   77,F
0444:  BTFSC  03.2
0445:  GOTO   488
0446:  BTFSC  6B.6
0447:  GOTO   3CA
0448:  BTFSC  6B.7
0449:  GOTO   40C
044A:  GOTO   46A
044B:  MOVLW  80
044C:  XORWF  6F,F
044D:  BTFSS  6F.7
044E:  GOTO   453
044F:  GOTO   48D
0450:  MOVF   66,W
0451:  MOVWF  6A
0452:  GOTO   460
0453:  MOVF   62,W
0454:  MOVWF  6A
0455:  MOVF   6F,F
0456:  BTFSS  03.2
0457:  GOTO   460
0458:  MOVF   6E,F
0459:  BTFSS  03.2
045A:  GOTO   460
045B:  MOVF   6D,F
045C:  BTFSS  03.2
045D:  GOTO   460
045E:  CLRF   77
045F:  GOTO   481
0460:  BTFSC  6F.7
0461:  GOTO   46A
0462:  BCF    03.0
0463:  RLF    6C,F
0464:  RLF    6D,F
0465:  RLF    6E,F
0466:  RLF    6F,F
0467:  DECFSZ 77,F
0468:  GOTO   460
0469:  GOTO   488
046A:  BTFSS  6A.7
046B:  GOTO   46E
046C:  BSF    6F.7
046D:  GOTO   481
046E:  BCF    6F.7
046F:  GOTO   481
0470:  MOVF   65,W
0471:  MOVWF  77
0472:  MOVF   66,W
0473:  MOVWF  6F
0474:  MOVF   67,W
0475:  MOVWF  6E
0476:  MOVF   68,W
0477:  MOVWF  6D
0478:  GOTO   481
0479:  MOVF   61,W
047A:  MOVWF  77
047B:  MOVF   62,W
047C:  MOVWF  6F
047D:  MOVF   63,W
047E:  MOVWF  6E
047F:  MOVF   64,W
0480:  MOVWF  6D
0481:  MOVF   6F,W
0482:  MOVWF  78
0483:  MOVF   6E,W
0484:  MOVWF  79
0485:  MOVF   6D,W
0486:  MOVWF  7A
0487:  GOTO   4C0
0488:  CLRF   77
0489:  CLRF   78
048A:  CLRF   79
048B:  CLRF   7A
048C:  GOTO   4C0
048D:  CLRF   6C
048E:  COMF   6D,F
048F:  COMF   6E,F
0490:  COMF   6F,F
0491:  COMF   6C,F
0492:  INCF   6C,F
0493:  BTFSS  03.2
0494:  GOTO   49B
0495:  INCF   6D,F
0496:  BTFSS  03.2
0497:  GOTO   49B
0498:  INCF   6E,F
0499:  BTFSC  03.2
049A:  INCF   6F,F
049B:  BTFSC  6B.0
049C:  GOTO   3A9
049D:  BTFSC  6B.1
049E:  GOTO   3EB
049F:  BTFSC  6B.2
04A0:  GOTO   421
04A1:  GOTO   450
04A2:  MOVF   00,W
04A3:  ADDWF  6D,F
04A4:  BTFSS  03.0
04A5:  GOTO   4AC
04A6:  INCF   6E,F
04A7:  BTFSS  03.2
04A8:  GOTO   4AC
04A9:  INCF   6F,F
04AA:  BTFSC  03.2
04AB:  BSF    69.0
04AC:  DECF   04,F
04AD:  MOVF   00,W
04AE:  ADDWF  6E,F
04AF:  BTFSS  03.0
04B0:  GOTO   4B4
04B1:  INCF   6F,F
04B2:  BTFSC  03.2
04B3:  BSF    69.0
04B4:  DECF   04,F
04B5:  MOVF   00,W
04B6:  BTFSS  00.7
04B7:  XORLW  80
04B8:  ADDWF  6F,F
04B9:  BTFSC  03.0
04BA:  BSF    69.0
04BB:  BTFSC  6B.4
04BC:  GOTO   3B0
04BD:  BTFSC  6B.5
04BE:  GOTO   3F2
04BF:  GOTO   428
04C0:  RETURN
*
0542:  MOVF   61,W
0543:  BTFSC  03.2
0544:  GOTO   607
0545:  MOVWF  6D
0546:  MOVF   65,W
0547:  BTFSC  03.2
0548:  GOTO   607
0549:  SUBWF  6D,F
054A:  BTFSS  03.0
054B:  GOTO   551
054C:  MOVLW  7F
054D:  ADDWF  6D,F
054E:  BTFSC  03.0
054F:  GOTO   607
0550:  GOTO   557
0551:  MOVLW  81
0552:  SUBWF  6D,F
0553:  BTFSS  03.0
0554:  GOTO   607
0555:  BTFSC  03.2
0556:  GOTO   607
0557:  MOVF   6D,W
0558:  MOVWF  77
0559:  CLRF   78
055A:  CLRF   79
055B:  CLRF   7A
055C:  CLRF   6C
055D:  MOVF   62,W
055E:  MOVWF  6B
055F:  BSF    6B.7
0560:  MOVF   63,W
0561:  MOVWF  6A
0562:  MOVF   64,W
0563:  MOVWF  69
0564:  MOVLW  19
0565:  MOVWF  6D
0566:  MOVF   68,W
0567:  SUBWF  69,F
0568:  BTFSC  03.0
0569:  GOTO   57A
056A:  MOVLW  01
056B:  SUBWF  6A,F
056C:  BTFSC  03.0
056D:  GOTO   57A
056E:  SUBWF  6B,F
056F:  BTFSC  03.0
0570:  GOTO   57A
0571:  SUBWF  6C,F
0572:  BTFSC  03.0
0573:  GOTO   57A
0574:  INCF   6C,F
0575:  INCF   6B,F
0576:  INCF   6A,F
0577:  MOVF   68,W
0578:  ADDWF  69,F
0579:  GOTO   5AC
057A:  MOVF   67,W
057B:  SUBWF  6A,F
057C:  BTFSC  03.0
057D:  GOTO   595
057E:  MOVLW  01
057F:  SUBWF  6B,F
0580:  BTFSC  03.0
0581:  GOTO   595
0582:  SUBWF  6C,F
0583:  BTFSC  03.0
0584:  GOTO   595
0585:  INCF   6C,F
0586:  INCF   6B,F
0587:  MOVF   67,W
0588:  ADDWF  6A,F
0589:  MOVF   68,W
058A:  ADDWF  69,F
058B:  BTFSS  03.0
058C:  GOTO   5AC
058D:  INCF   6A,F
058E:  BTFSS  03.2
058F:  GOTO   5AC
0590:  INCF   6B,F
0591:  BTFSS  03.2
0592:  GOTO   5AC
0593:  INCF   6C,F
0594:  GOTO   5AC
0595:  MOVF   66,W
0596:  IORLW  80
0597:  SUBWF  6B,F
0598:  BTFSC  03.0
0599:  GOTO   5AB
059A:  MOVLW  01
059B:  SUBWF  6C,F
059C:  BTFSC  03.0
059D:  GOTO   5AB
059E:  INCF   6C,F
059F:  MOVF   66,W
05A0:  IORLW  80
05A1:  ADDWF  6B,F
05A2:  MOVF   67,W
05A3:  ADDWF  6A,F
05A4:  BTFSS  03.0
05A5:  GOTO   589
05A6:  INCF   6B,F
05A7:  BTFSS  03.2
05A8:  GOTO   589
05A9:  INCF   6C,F
05AA:  GOTO   589
05AB:  BSF    7A.0
05AC:  DECFSZ 6D,F
05AD:  GOTO   5AF
05AE:  GOTO   5BA
05AF:  BCF    03.0
05B0:  RLF    69,F
05B1:  RLF    6A,F
05B2:  RLF    6B,F
05B3:  RLF    6C,F
05B4:  BCF    03.0
05B5:  RLF    7A,F
05B6:  RLF    79,F
05B7:  RLF    78,F
05B8:  RLF    6E,F
05B9:  GOTO   566
05BA:  BTFSS  6E.0
05BB:  GOTO   5C2
05BC:  BCF    03.0
05BD:  RRF    78,F
05BE:  RRF    79,F
05BF:  RRF    7A,F
05C0:  RRF    6E,F
05C1:  GOTO   5C5
05C2:  DECF   77,F
05C3:  BTFSC  03.2
05C4:  GOTO   607
05C5:  BTFSC  6E.7
05C6:  GOTO   5EE
05C7:  BCF    03.0
05C8:  RLF    69,F
05C9:  RLF    6A,F
05CA:  RLF    6B,F
05CB:  RLF    6C,F
05CC:  MOVF   68,W
05CD:  SUBWF  69,F
05CE:  BTFSC  03.0
05CF:  GOTO   5DA
05D0:  MOVLW  01
05D1:  SUBWF  6A,F
05D2:  BTFSC  03.0
05D3:  GOTO   5DA
05D4:  SUBWF  6B,F
05D5:  BTFSC  03.0
05D6:  GOTO   5DA
05D7:  SUBWF  6C,F
05D8:  BTFSS  03.0
05D9:  GOTO   5FD
05DA:  MOVF   67,W
05DB:  SUBWF  6A,F
05DC:  BTFSC  03.0
05DD:  GOTO   5E5
05DE:  MOVLW  01
05DF:  SUBWF  6B,F
05E0:  BTFSC  03.0
05E1:  GOTO   5E5
05E2:  SUBWF  6C,F
05E3:  BTFSS  03.0
05E4:  GOTO   5FD
05E5:  MOVF   66,W
05E6:  IORLW  80
05E7:  SUBWF  6B,F
05E8:  BTFSC  03.0
05E9:  GOTO   5EE
05EA:  MOVLW  01
05EB:  SUBWF  6C,F
05EC:  BTFSS  03.0
05ED:  GOTO   5FD
05EE:  INCF   7A,F
05EF:  BTFSS  03.2
05F0:  GOTO   5FD
05F1:  INCF   79,F
05F2:  BTFSS  03.2
05F3:  GOTO   5FD
05F4:  INCF   78,F
05F5:  BTFSS  03.2
05F6:  GOTO   5FD
05F7:  INCF   77,F
05F8:  BTFSC  03.2
05F9:  GOTO   607
05FA:  RRF    78,F
05FB:  RRF    79,F
05FC:  RRF    7A,F
05FD:  MOVF   62,W
05FE:  MOVWF  6D
05FF:  MOVF   66,W
0600:  XORWF  6D,F
0601:  BTFSS  6D.7
0602:  GOTO   605
0603:  BSF    78.7
0604:  GOTO   60B
0605:  BCF    78.7
0606:  GOTO   60B
0607:  CLRF   77
0608:  CLRF   78
0609:  CLRF   79
060A:  CLRF   7A
*
073D:  MOVF   4C,W
073E:  SUBLW  B6
073F:  MOVWF  4C
0740:  CLRF   7A
0741:  MOVF   4D,W
0742:  MOVWF  50
0743:  BSF    4D.7
0744:  BCF    03.0
0745:  RRF    4D,F
0746:  RRF    4E,F
0747:  RRF    4F,F
0748:  RRF    7A,F
0749:  RRF    79,F
074A:  RRF    78,F
074B:  RRF    77,F
074C:  DECFSZ 4C,F
074D:  GOTO   744
074E:  BTFSS  50.7
074F:  GOTO   75B
0750:  COMF   77,F
0751:  COMF   78,F
0752:  COMF   79,F
0753:  COMF   7A,F
0754:  INCF   77,F
0755:  BTFSC  03.2
0756:  INCF   78,F
0757:  BTFSC  03.2
0758:  INCF   79,F
0759:  BTFSC  03.2
075A:  INCF   7A,F
075B:  RETURN
075C:  BTFSC  03.1
075D:  GOTO   761
075E:  MOVLW  54
075F:  MOVWF  04
0760:  BCF    03.7
0761:  CLRF   77
0762:  CLRF   78
0763:  CLRF   79
0764:  CLRF   7A
0765:  CLRF   54
0766:  CLRF   55
0767:  CLRF   56
0768:  CLRF   57
0769:  MOVF   53,W
076A:  IORWF  52,W
076B:  IORWF  51,W
076C:  IORWF  50,W
076D:  BTFSC  03.2
076E:  GOTO   79F
076F:  MOVLW  20
0770:  MOVWF  58
0771:  BCF    03.0
0772:  RLF    4C,F
0773:  RLF    4D,F
0774:  RLF    4E,F
0775:  RLF    4F,F
0776:  RLF    54,F
0777:  RLF    55,F
0778:  RLF    56,F
0779:  RLF    57,F
077A:  MOVF   53,W
077B:  SUBWF  57,W
077C:  BTFSS  03.2
077D:  GOTO   788
077E:  MOVF   52,W
077F:  SUBWF  56,W
0780:  BTFSS  03.2
0781:  GOTO   788
0782:  MOVF   51,W
0783:  SUBWF  55,W
0784:  BTFSS  03.2
0785:  GOTO   788
0786:  MOVF   50,W
0787:  SUBWF  54,W
0788:  BTFSS  03.0
0789:  GOTO   799
078A:  MOVF   50,W
078B:  SUBWF  54,F
078C:  MOVF   51,W
078D:  BTFSS  03.0
078E:  INCFSZ 51,W
078F:  SUBWF  55,F
0790:  MOVF   52,W
0791:  BTFSS  03.0
0792:  INCFSZ 52,W
0793:  SUBWF  56,F
0794:  MOVF   53,W
0795:  BTFSS  03.0
0796:  INCFSZ 53,W
0797:  SUBWF  57,F
0798:  BSF    03.0
0799:  RLF    77,F
079A:  RLF    78,F
079B:  RLF    79,F
079C:  RLF    7A,F
079D:  DECFSZ 58,F
079E:  GOTO   771
079F:  MOVF   54,W
07A0:  MOVWF  00
07A1:  INCF   04,F
07A2:  MOVF   55,W
07A3:  MOVWF  00
07A4:  INCF   04,F
07A5:  MOVF   56,W
07A6:  MOVWF  00
07A7:  INCF   04,F
07A8:  MOVF   57,W
07A9:  MOVWF  00
07AA:  RETURN
07AB:  MOVF   40,W
07AC:  MOVWF  47
07AD:  MOVF   44,W
07AE:  XORWF  47,F
07AF:  BTFSS  47.7
07B0:  GOTO   7B6
07B1:  BCF    03.2
07B2:  BCF    03.0
07B3:  BTFSC  40.7
07B4:  BSF    03.0
07B5:  GOTO   7E9
07B6:  MOVF   40,W
07B7:  MOVWF  47
07B8:  MOVF   43,W
07B9:  MOVWF  48
07BA:  MOVF   3F,W
07BB:  SUBWF  48,F
07BC:  BTFSC  03.2
07BD:  GOTO   7C4
07BE:  BTFSS  47.7
07BF:  GOTO   7E9
07C0:  MOVF   03,W
07C1:  XORLW  01
07C2:  MOVWF  03
07C3:  GOTO   7E9
07C4:  MOVF   44,W
07C5:  MOVWF  48
07C6:  MOVF   40,W
07C7:  SUBWF  48,F
07C8:  BTFSC  03.2
07C9:  GOTO   7D0
07CA:  BTFSS  47.7
07CB:  GOTO   7E9
07CC:  MOVF   03,W
07CD:  XORLW  01
07CE:  MOVWF  03
07CF:  GOTO   7E9
07D0:  MOVF   45,W
07D1:  MOVWF  48
07D2:  MOVF   41,W
07D3:  SUBWF  48,F
07D4:  BTFSC  03.2
07D5:  GOTO   7DC
07D6:  BTFSS  47.7
07D7:  GOTO   7E9
07D8:  MOVF   03,W
07D9:  XORLW  01
07DA:  MOVWF  03
07DB:  GOTO   7E9
07DC:  MOVF   46,W
07DD:  MOVWF  48
07DE:  MOVF   42,W
07DF:  SUBWF  48,F
07E0:  BTFSC  03.2
07E1:  GOTO   7E8
07E2:  BTFSS  47.7
07E3:  GOTO   7E9
07E4:  MOVF   03,W
07E5:  XORLW  01
07E6:  MOVWF  03
07E7:  GOTO   7E9
07E8:  BCF    03.0
07E9:  RETURN
*
0800:  MOVF   04,W
0801:  MOVWF  44
0802:  MOVF   43,W
0803:  MOVWF  46
0804:  BTFSC  03.2
0805:  GOTO   021
0806:  MOVF   42,W
0807:  MOVWF  60
0808:  MOVF   41,W
0809:  MOVWF  5F
080A:  MOVF   40,W
080B:  MOVWF  5E
080C:  MOVF   3F,W
080D:  MOVWF  5D
080E:  CLRF   64
080F:  CLRF   63
0810:  MOVLW  20
0811:  MOVWF  62
0812:  MOVLW  82
0813:  MOVWF  61
0814:  BCF    0A.3
0815:  CALL   2EE
0816:  BSF    0A.3
0817:  MOVF   7A,W
0818:  MOVWF  42
0819:  MOVF   79,W
081A:  MOVWF  41
081B:  MOVF   78,W
081C:  MOVWF  40
081D:  MOVF   77,W
081E:  MOVWF  3F
081F:  DECFSZ 46,F
0820:  GOTO   006
0821:  MOVF   42,W
0822:  MOVWF  4F
0823:  MOVF   41,W
0824:  MOVWF  4E
0825:  MOVF   40,W
0826:  MOVWF  4D
0827:  MOVF   3F,W
0828:  MOVWF  4C
0829:  BCF    0A.3
082A:  CALL   73D
082B:  BSF    0A.3
082C:  MOVF   7A,W
082D:  MOVWF  42
082E:  MOVF   79,W
082F:  MOVWF  41
0830:  MOVF   78,W
0831:  MOVWF  40
0832:  MOVF   77,W
0833:  MOVWF  3F
0834:  BTFSS  42.7
0835:  GOTO   043
0836:  DECF   44,F
0837:  BSF    44.5
0838:  COMF   3F,F
0839:  COMF   40,F
083A:  COMF   41,F
083B:  COMF   42,F
083C:  INCF   3F,F
083D:  BTFSC  03.2
083E:  INCF   40,F
083F:  BTFSC  03.2
0840:  INCF   41,F
0841:  BTFSC  03.2
0842:  INCF   42,F
0843:  MOVLW  3B
0844:  MOVWF  4B
0845:  MOVLW  9A
0846:  MOVWF  4A
0847:  MOVLW  CA
0848:  MOVWF  49
0849:  CLRF   48
084A:  MOVLW  0A
084B:  MOVWF  46
084C:  MOVF   43,W
084D:  BTFSC  03.2
084E:  INCF   44,F
084F:  BSF    03.1
0850:  MOVLW  3F
0851:  MOVWF  04
0852:  BCF    03.7
0853:  MOVF   42,W
0854:  MOVWF  4F
0855:  MOVF   41,W
0856:  MOVWF  4E
0857:  MOVF   40,W
0858:  MOVWF  4D
0859:  MOVF   3F,W
085A:  MOVWF  4C
085B:  MOVF   4B,W
085C:  MOVWF  53
085D:  MOVF   4A,W
085E:  MOVWF  52
085F:  MOVF   49,W
0860:  MOVWF  51
0861:  MOVF   48,W
0862:  MOVWF  50
0863:  BCF    0A.3
0864:  CALL   75C
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVF   77,F
0868:  BTFSS  03.2
0869:  GOTO   07D
086A:  INCF   43,W
086B:  SUBWF  46,W
086C:  BTFSC  03.2
086D:  GOTO   07D
086E:  MOVF   44,W
086F:  BTFSC  03.2
0870:  GOTO   07F
0871:  ANDLW  0F
0872:  SUBWF  46,W
0873:  BTFSC  03.2
0874:  GOTO   077
0875:  BTFSC  03.0
0876:  GOTO   0B7
0877:  BTFSC  44.7
0878:  GOTO   0B7
0879:  BTFSC  44.6
087A:  GOTO   07F
087B:  MOVLW  20
087C:  GOTO   0B1
087D:  MOVLW  20
087E:  ANDWF  44,F
087F:  BTFSS  44.5
0880:  GOTO   08F
0881:  BCF    44.5
0882:  MOVF   43,W
0883:  BTFSS  03.2
0884:  DECF   44,F
0885:  MOVF   77,W
0886:  MOVWF  44
0887:  MOVLW  2D
0888:  MOVWF  4C
0889:  BCF    0A.3
088A:  CALL   1BB
088B:  BSF    0A.3
088C:  MOVF   44,W
088D:  MOVWF  77
088E:  CLRF   44
088F:  MOVF   43,W
0890:  SUBWF  46,W
0891:  BTFSS  03.2
0892:  GOTO   09F
0893:  MOVF   77,W
0894:  MOVWF  44
0895:  MOVLW  2E
0896:  MOVWF  4C
0897:  BCF    0A.3
0898:  CALL   1BB
0899:  BSF    0A.3
089A:  MOVF   44,W
089B:  MOVWF  77
089C:  MOVLW  20
089D:  ANDWF  44,F
089E:  MOVLW  00
089F:  MOVLW  30
08A0:  BTFSS  44.5
08A1:  GOTO   0B1
08A2:  BCF    44.5
08A3:  MOVF   43,W
08A4:  BTFSS  03.2
08A5:  DECF   44,F
08A6:  MOVF   77,W
08A7:  MOVWF  44
08A8:  MOVLW  2D
08A9:  MOVWF  4C
08AA:  BCF    0A.3
08AB:  CALL   1BB
08AC:  BSF    0A.3
08AD:  MOVF   44,W
08AE:  MOVWF  77
08AF:  CLRF   44
08B0:  MOVLW  30
08B1:  ADDWF  77,F
08B2:  MOVF   77,W
08B3:  MOVWF  4C
08B4:  BCF    0A.3
08B5:  CALL   1BB
08B6:  BSF    0A.3
08B7:  BCF    03.1
08B8:  MOVF   4B,W
08B9:  MOVWF  4F
08BA:  MOVF   4A,W
08BB:  MOVWF  4E
08BC:  MOVF   49,W
08BD:  MOVWF  4D
08BE:  MOVF   48,W
08BF:  MOVWF  4C
08C0:  CLRF   53
08C1:  CLRF   52
08C2:  CLRF   51
08C3:  MOVLW  0A
08C4:  MOVWF  50
08C5:  BCF    0A.3
08C6:  CALL   75C
08C7:  BSF    0A.3
08C8:  MOVF   7A,W
08C9:  MOVWF  4B
08CA:  MOVF   79,W
08CB:  MOVWF  4A
08CC:  MOVF   78,W
08CD:  MOVWF  49
08CE:  MOVF   77,W
08CF:  MOVWF  48
08D0:  DECFSZ 46,F
08D1:  GOTO   04F
08D2:  RETURN
08D3:  MOVF   0B,W
08D4:  MOVWF  40
08D5:  BCF    0B.7
08D6:  BSF    03.5
08D7:  BSF    03.6
08D8:  BSF    0C.7
08D9:  BSF    0C.0
08DA:  NOP
08DB:  NOP
08DC:  BCF    03.5
08DD:  BCF    03.6
08DE:  BTFSC  40.7
08DF:  BSF    0B.7
08E0:  BTFSC  03.0
08E1:  GOTO   10B
08E2:  BSF    03.6
08E3:  MOVF   0C,W
08E4:  ANDLW  7F
08E5:  BCF    03.6
08E6:  MOVWF  40
08E7:  BSF    03.6
08E8:  MOVF   0D,W
08E9:  BCF    03.6
08EA:  MOVWF  41
08EB:  BSF    03.6
08EC:  MOVF   0F,W
08ED:  BCF    03.6
08EE:  MOVWF  42
08EF:  MOVF   40,W
08F0:  BTFSS  0C.4
08F1:  GOTO   0F0
08F2:  MOVWF  19
08F3:  MOVF   41,W
08F4:  BSF    03.6
08F5:  MOVWF  0D
08F6:  BCF    03.6
08F7:  MOVF   42,W
08F8:  BSF    03.6
08F9:  MOVWF  0F
08FA:  BCF    03.6
08FB:  MOVF   0B,W
08FC:  MOVWF  43
08FD:  BCF    0B.7
08FE:  BSF    03.5
08FF:  BSF    03.6
0900:  BSF    0C.7
0901:  BSF    0C.0
0902:  NOP
0903:  NOP
0904:  BCF    03.5
0905:  BCF    03.6
0906:  BTFSC  43.7
0907:  BSF    0B.7
0908:  DECFSZ 3F,F
0909:  GOTO   10B
090A:  GOTO   12B
090B:  BSF    03.6
090C:  RLF    0C,W
090D:  RLF    0E,W
090E:  ANDLW  7F
090F:  BCF    03.6
0910:  MOVWF  40
0911:  BSF    03.6
0912:  MOVF   0D,W
0913:  BCF    03.6
0914:  MOVWF  41
0915:  BSF    03.6
0916:  MOVF   0F,W
0917:  BCF    03.6
0918:  MOVWF  42
0919:  MOVF   40,W
091A:  BTFSS  0C.4
091B:  GOTO   11A
091C:  MOVWF  19
091D:  MOVF   41,W
091E:  BSF    03.6
091F:  MOVWF  0D
0920:  BCF    03.6
0921:  MOVF   42,W
0922:  BSF    03.6
0923:  MOVWF  0F
0924:  INCF   0D,F
0925:  BTFSC  03.2
0926:  INCF   0F,F
0927:  BCF    03.0
0928:  BCF    03.6
0929:  DECFSZ 3F,F
092A:  GOTO   0D3
092B:  RETURN
092C:  MOVF   04,W
092D:  MOVWF  44
092E:  MOVF   43,W
092F:  MOVWF  46
0930:  BTFSC  03.2
0931:  GOTO   14D
0932:  MOVF   42,W
0933:  MOVWF  60
0934:  MOVF   41,W
0935:  MOVWF  5F
0936:  MOVF   40,W
0937:  MOVWF  5E
0938:  MOVF   3F,W
0939:  MOVWF  5D
093A:  CLRF   64
093B:  CLRF   63
093C:  MOVLW  20
093D:  MOVWF  62
093E:  MOVLW  82
093F:  MOVWF  61
0940:  BCF    0A.3
0941:  CALL   2EE
0942:  BSF    0A.3
0943:  MOVF   7A,W
0944:  MOVWF  42
0945:  MOVF   79,W
0946:  MOVWF  41
0947:  MOVF   78,W
0948:  MOVWF  40
0949:  MOVF   77,W
094A:  MOVWF  3F
094B:  DECFSZ 46,F
094C:  GOTO   132
094D:  MOVF   42,W
094E:  MOVWF  4F
094F:  MOVF   41,W
0950:  MOVWF  4E
0951:  MOVF   40,W
0952:  MOVWF  4D
0953:  MOVF   3F,W
0954:  MOVWF  4C
0955:  BCF    0A.3
0956:  CALL   73D
0957:  BSF    0A.3
0958:  MOVF   7A,W
0959:  MOVWF  42
095A:  MOVF   79,W
095B:  MOVWF  41
095C:  MOVF   78,W
095D:  MOVWF  40
095E:  MOVF   77,W
095F:  MOVWF  3F
0960:  BTFSS  42.7
0961:  GOTO   16F
0962:  DECF   44,F
0963:  BSF    44.5
0964:  COMF   3F,F
0965:  COMF   40,F
0966:  COMF   41,F
0967:  COMF   42,F
0968:  INCF   3F,F
0969:  BTFSC  03.2
096A:  INCF   40,F
096B:  BTFSC  03.2
096C:  INCF   41,F
096D:  BTFSC  03.2
096E:  INCF   42,F
096F:  MOVLW  3B
0970:  MOVWF  4B
0971:  MOVLW  9A
0972:  MOVWF  4A
0973:  MOVLW  CA
0974:  MOVWF  49
0975:  CLRF   48
0976:  MOVLW  0A
0977:  MOVWF  46
0978:  MOVF   43,W
0979:  BTFSC  03.2
097A:  INCF   44,F
097B:  BSF    03.1
097C:  MOVLW  3F
097D:  MOVWF  04
097E:  BCF    03.7
097F:  MOVF   42,W
0980:  MOVWF  4F
0981:  MOVF   41,W
0982:  MOVWF  4E
0983:  MOVF   40,W
0984:  MOVWF  4D
0985:  MOVF   3F,W
0986:  MOVWF  4C
0987:  MOVF   4B,W
0988:  MOVWF  53
0989:  MOVF   4A,W
098A:  MOVWF  52
098B:  MOVF   49,W
098C:  MOVWF  51
098D:  MOVF   48,W
098E:  MOVWF  50
098F:  BCF    0A.3
0990:  CALL   75C
0991:  BSF    0A.3
0992:  MOVF   78,W
0993:  MOVF   77,F
0994:  BTFSS  03.2
0995:  GOTO   1A9
0996:  INCF   43,W
0997:  SUBWF  46,W
0998:  BTFSC  03.2
0999:  GOTO   1A9
099A:  MOVF   44,W
099B:  BTFSC  03.2
099C:  GOTO   1AB
099D:  ANDLW  0F
099E:  SUBWF  46,W
099F:  BTFSC  03.2
09A0:  GOTO   1A3
09A1:  BTFSC  03.0
09A2:  GOTO   1DF
09A3:  BTFSC  44.7
09A4:  GOTO   1DF
09A5:  BTFSC  44.6
09A6:  GOTO   1AB
09A7:  MOVLW  20
09A8:  GOTO   1DA
09A9:  MOVLW  20
09AA:  ANDWF  44,F
09AB:  BTFSS  44.5
09AC:  GOTO   1BA
09AD:  BCF    44.5
09AE:  MOVF   43,W
09AF:  BTFSS  03.2
09B0:  DECF   44,F
09B1:  MOVF   77,W
09B2:  MOVWF  44
09B3:  MOVLW  2D
09B4:  BTFSS  0C.4
09B5:  GOTO   1B4
09B6:  MOVWF  19
09B7:  MOVF   44,W
09B8:  MOVWF  77
09B9:  CLRF   44
09BA:  MOVF   43,W
09BB:  SUBWF  46,W
09BC:  BTFSS  03.2
09BD:  GOTO   1C9
09BE:  MOVF   77,W
09BF:  MOVWF  44
09C0:  MOVLW  2E
09C1:  BTFSS  0C.4
09C2:  GOTO   1C1
09C3:  MOVWF  19
09C4:  MOVF   44,W
09C5:  MOVWF  77
09C6:  MOVLW  20
09C7:  ANDWF  44,F
09C8:  MOVLW  00
09C9:  MOVLW  30
09CA:  BTFSS  44.5
09CB:  GOTO   1DA
09CC:  BCF    44.5
09CD:  MOVF   43,W
09CE:  BTFSS  03.2
09CF:  DECF   44,F
09D0:  MOVF   77,W
09D1:  MOVWF  44
09D2:  MOVLW  2D
09D3:  BTFSS  0C.4
09D4:  GOTO   1D3
09D5:  MOVWF  19
09D6:  MOVF   44,W
09D7:  MOVWF  77
09D8:  CLRF   44
09D9:  MOVLW  30
09DA:  ADDWF  77,F
09DB:  MOVF   77,W
09DC:  BTFSS  0C.4
09DD:  GOTO   1DC
09DE:  MOVWF  19
09DF:  BCF    03.1
09E0:  MOVF   4B,W
09E1:  MOVWF  4F
09E2:  MOVF   4A,W
09E3:  MOVWF  4E
09E4:  MOVF   49,W
09E5:  MOVWF  4D
09E6:  MOVF   48,W
09E7:  MOVWF  4C
09E8:  CLRF   53
09E9:  CLRF   52
09EA:  CLRF   51
09EB:  MOVLW  0A
09EC:  MOVWF  50
09ED:  BCF    0A.3
09EE:  CALL   75C
09EF:  BSF    0A.3
09F0:  MOVF   7A,W
09F1:  MOVWF  4B
09F2:  MOVF   79,W
09F3:  MOVWF  4A
09F4:  MOVF   78,W
09F5:  MOVWF  49
09F6:  MOVF   77,W
09F7:  MOVWF  48
09F8:  DECFSZ 46,F
09F9:  GOTO   17B
09FA:  RETURN
09FB:  MOVF   78,W
09FC:  MOVF   3F,W
09FD:  MOVWF  52
09FE:  MOVLW  64
09FF:  MOVWF  53
0A00:  BCF    0A.3
0A01:  CALL   275
0A02:  BSF    0A.3
0A03:  MOVF   77,W
0A04:  MOVWF  3F
0A05:  MOVF   78,W
0A06:  MOVLW  30
0A07:  BTFSS  03.2
0A08:  GOTO   210
0A09:  BTFSS  40.1
0A0A:  GOTO   218
0A0B:  BTFSC  40.3
0A0C:  GOTO   218
0A0D:  BTFSC  40.4
0A0E:  MOVLW  20
0A0F:  GOTO   213
0A10:  BCF    40.3
0A11:  BCF    40.4
0A12:  BSF    40.0
0A13:  ADDWF  78,F
0A14:  MOVF   78,W
0A15:  BTFSS  0C.4
0A16:  GOTO   215
0A17:  MOVWF  19
0A18:  MOVF   3F,W
0A19:  MOVWF  52
0A1A:  MOVLW  0A
0A1B:  MOVWF  53
0A1C:  BCF    0A.3
0A1D:  CALL   275
0A1E:  BSF    0A.3
0A1F:  MOVF   77,W
0A20:  MOVWF  3F
0A21:  MOVF   78,W
0A22:  MOVLW  30
0A23:  BTFSS  03.2
0A24:  GOTO   22B
0A25:  BTFSC  40.3
0A26:  GOTO   230
0A27:  BTFSS  40.0
0A28:  GOTO   230
0A29:  BTFSC  40.4
0A2A:  MOVLW  20
0A2B:  ADDWF  78,F
0A2C:  MOVF   78,W
0A2D:  BTFSS  0C.4
0A2E:  GOTO   22D
0A2F:  MOVWF  19
0A30:  MOVLW  30
0A31:  ADDWF  3F,F
0A32:  MOVF   3F,W
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
0A36:  RETURN
0A37:  MOVF   0B,W
0A38:  MOVWF  3F
0A39:  BCF    0B.7
0A3A:  BSF    03.5
0A3B:  BSF    03.6
0A3C:  BSF    0C.7
0A3D:  BSF    0C.0
0A3E:  NOP
0A3F:  NOP
0A40:  BCF    03.5
0A41:  BCF    03.6
0A42:  BTFSC  3F.7
0A43:  BSF    0B.7
0A44:  BSF    03.6
0A45:  MOVF   0C,W
0A46:  ANDLW  7F
0A47:  BTFSC  03.2
0A48:  GOTO   28D
0A49:  BCF    03.6
0A4A:  MOVWF  3F
0A4B:  BSF    03.6
0A4C:  MOVF   0D,W
0A4D:  BCF    03.6
0A4E:  MOVWF  40
0A4F:  BSF    03.6
0A50:  MOVF   0F,W
0A51:  BCF    03.6
0A52:  MOVWF  41
0A53:  MOVF   3F,W
0A54:  BTFSS  0C.4
0A55:  GOTO   254
0A56:  MOVWF  19
0A57:  MOVF   40,W
0A58:  BSF    03.6
0A59:  MOVWF  0D
0A5A:  BCF    03.6
0A5B:  MOVF   41,W
0A5C:  BSF    03.6
0A5D:  MOVWF  0F
0A5E:  BCF    03.6
0A5F:  MOVF   0B,W
0A60:  MOVWF  42
0A61:  BCF    0B.7
0A62:  BSF    03.5
0A63:  BSF    03.6
0A64:  BSF    0C.7
0A65:  BSF    0C.0
0A66:  NOP
0A67:  NOP
0A68:  BCF    03.5
0A69:  BCF    03.6
0A6A:  BTFSC  42.7
0A6B:  BSF    0B.7
0A6C:  BSF    03.6
0A6D:  RLF    0C,W
0A6E:  RLF    0E,W
0A6F:  ANDLW  7F
0A70:  BTFSC  03.2
0A71:  GOTO   28D
0A72:  BCF    03.6
0A73:  MOVWF  3F
0A74:  BSF    03.6
0A75:  MOVF   0D,W
0A76:  BCF    03.6
0A77:  MOVWF  40
0A78:  BSF    03.6
0A79:  MOVF   0F,W
0A7A:  BCF    03.6
0A7B:  MOVWF  41
0A7C:  MOVF   3F,W
0A7D:  BTFSS  0C.4
0A7E:  GOTO   27D
0A7F:  MOVWF  19
0A80:  MOVF   40,W
0A81:  BSF    03.6
0A82:  MOVWF  0D
0A83:  BCF    03.6
0A84:  MOVF   41,W
0A85:  BSF    03.6
0A86:  MOVWF  0F
0A87:  INCF   0D,F
0A88:  BTFSC  03.2
0A89:  INCF   0F,F
0A8A:  BCF    03.6
0A8B:  GOTO   237
0A8C:  BSF    03.6
0A8D:  BCF    03.6
0A8E:  RETURN
....................  
.................... #list 
....................  
.................... #fuses INTRC_IO, NOWDT, PROTECT, NOLVP, MCLR, NOLVP, NOBROWNOUT 
.................... #use delay(INTERNAL=4000000) 
*
0104:  MOVLW  4D
0105:  MOVWF  04
0106:  BCF    03.7
0107:  MOVF   00,W
0108:  BTFSC  03.2
0109:  GOTO   118
010A:  MOVLW  01
010B:  MOVWF  78
010C:  CLRF   77
010D:  DECFSZ 77,F
010E:  GOTO   10D
010F:  DECFSZ 78,F
0110:  GOTO   10C
0111:  MOVLW  4A
0112:  MOVWF  77
0113:  DECFSZ 77,F
0114:  GOTO   113
0115:  GOTO   116
0116:  DECFSZ 00,F
0117:  GOTO   10A
0118:  RETURN
.................... // se inicializa el puerto serie en el microcontrolador 
.................... #use RS232(baud = 9600, xmit = PIN_C6, rcv = PIN_C7, timeout = 100)  
*
023D:  MOVLW  01
023E:  MOVWF  40
023F:  MOVLW  40
0240:  MOVWF  3F
0241:  MOVLW  67
0242:  MOVWF  77
0243:  DECFSZ 77,F
0244:  GOTO   243
0245:  GOTO   246
0246:  DECFSZ 3F,F
0247:  GOTO   24D
0248:  DECFSZ 40,F
0249:  GOTO   24D
024A:  CLRF   20
024B:  CLRF   78
024C:  GOTO   257
024D:  BTFSS  0C.5
024E:  GOTO   241
024F:  MOVF   18,W
0250:  MOVWF  20
0251:  MOVF   1A,W
0252:  MOVWF  78
0253:  BTFSS  20.1
0254:  GOTO   257
0255:  BCF    18.4
0256:  BSF    18.4
0257:  RETURN
.................... //argumentos PS(ancho de banda (Tx bits/s), pin Tx, pin Rx, tiempo de respuesta) 
....................  //Sensores 
.................... #define DHT11_PIN PIN_A0 
.................... #define spuerta PIN_A1 
.................... // se define el puerto D completo para la conexion al LCD 
.................... #define LCD_DATA_PORT getenv("SFR:PORTD") 
.................... // se define el uso de la biblioteca para manipular LCD 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0131:  MOVLW  0F
0132:  BSF    03.5
0133:  ANDWF  08,W
0134:  IORLW  F0
0135:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0136:  BCF    03.5
0137:  BSF    08.2
....................    delay_cycles(1); 
0138:  NOP
....................    lcd_output_enable(1); 
0139:  BSF    08.0
....................    delay_cycles(1); 
013A:  NOP
....................    high = lcd_read_nibble(); 
013B:  CALL   125
013C:  MOVF   78,W
013D:  MOVWF  54
....................        
....................    lcd_output_enable(0); 
013E:  BCF    08.0
....................    delay_cycles(1); 
013F:  NOP
....................    lcd_output_enable(1); 
0140:  BSF    08.0
....................    delay_us(1); 
0141:  NOP
....................    low = lcd_read_nibble(); 
0142:  CALL   125
0143:  MOVF   78,W
0144:  MOVWF  53
....................        
....................    lcd_output_enable(0); 
0145:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0146:  MOVLW  0F
0147:  BSF    03.5
0148:  ANDWF  08,W
0149:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
014A:  BCF    03.5
014B:  SWAPF  54,W
014C:  MOVWF  77
014D:  MOVLW  F0
014E:  ANDWF  77,F
014F:  MOVF   77,W
0150:  IORWF  53,W
0151:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0125:  MOVF   08,W
0126:  MOVWF  77
0127:  SWAPF  08,W
0128:  ANDLW  0F
0129:  MOVWF  78
....................   #endif 
012A:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0119:  SWAPF  54,W
011A:  ANDLW  F0
011B:  MOVWF  77
011C:  MOVLW  0F
011D:  ANDWF  08,W
011E:  IORWF  77,W
011F:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0120:  NOP
....................    lcd_output_enable(1); 
0121:  BSF    08.0
....................    delay_us(2); 
0122:  GOTO   123
....................    lcd_output_enable(0); 
0123:  BCF    08.0
0124:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
012B:  BSF    03.5
012C:  BCF    08.0
....................    lcd_rs_tris(); 
012D:  BCF    08.1
....................    lcd_rw_tris(); 
012E:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
012F:  BCF    03.5
0130:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0152:  MOVF   78,W
0153:  MOVWF  53
0154:  BTFSC  53.7
0155:  GOTO   131
....................    lcd_output_rs(address); 
0156:  BTFSS  51.0
0157:  BCF    08.1
0158:  BTFSC  51.0
0159:  BSF    08.1
....................    delay_cycles(1); 
015A:  NOP
....................    lcd_output_rw(0); 
015B:  BCF    08.2
....................    delay_cycles(1); 
015C:  NOP
....................    lcd_output_enable(0); 
015D:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
015E:  SWAPF  52,W
015F:  MOVWF  53
0160:  MOVLW  0F
0161:  ANDWF  53,F
0162:  MOVF   53,W
0163:  MOVWF  54
0164:  CALL   119
....................    lcd_send_nibble(n & 0xf); 
0165:  MOVF   52,W
0166:  ANDLW  0F
0167:  MOVWF  53
0168:  MOVWF  54
0169:  CALL   119
016A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
016B:  MOVLW  28
016C:  MOVWF  40
016D:  MOVLW  0C
016E:  MOVWF  41
016F:  MOVLW  01
0170:  MOVWF  42
0171:  MOVLW  06
0172:  MOVWF  43
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0173:  BCF    08.0
....................    lcd_output_rs(0); 
0174:  BCF    08.1
....................    lcd_output_rw(0); 
0175:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0176:  MOVLW  0F
0177:  BSF    03.5
0178:  ANDWF  08,W
0179:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
017A:  BCF    08.0
....................    lcd_rs_tris(); 
017B:  BCF    08.1
....................    lcd_rw_tris(); 
017C:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
017D:  MOVLW  0F
017E:  BCF    03.5
017F:  MOVWF  4D
0180:  CALL   104
....................    for(i=1;i<=3;++i) 
0181:  MOVLW  01
0182:  MOVWF  3F
0183:  MOVF   3F,W
0184:  SUBLW  03
0185:  BTFSS  03.0
0186:  GOTO   18F
....................    { 
....................        lcd_send_nibble(3); 
0187:  MOVLW  03
0188:  MOVWF  54
0189:  CALL   119
....................        delay_ms(5); 
018A:  MOVLW  05
018B:  MOVWF  4D
018C:  CALL   104
018D:  INCF   3F,F
018E:  GOTO   183
....................    } 
....................     
....................    lcd_send_nibble(2); 
018F:  MOVLW  02
0190:  MOVWF  54
0191:  CALL   119
....................    delay_ms(5); 
0192:  MOVLW  05
0193:  MOVWF  4D
0194:  CALL   104
....................    for(i=0;i<=3;++i) 
0195:  CLRF   3F
0196:  MOVF   3F,W
0197:  SUBLW  03
0198:  BTFSS  03.0
0199:  GOTO   1A6
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
019A:  MOVLW  40
019B:  ADDWF  3F,W
019C:  MOVWF  04
019D:  BCF    03.7
019E:  MOVF   00,W
019F:  MOVWF  44
01A0:  CLRF   51
01A1:  MOVF   44,W
01A2:  MOVWF  52
01A3:  CALL   12B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01A4:  INCF   3F,F
01A5:  GOTO   196
01A6:  BSF    0A.3
01A7:  BCF    0A.4
01A8:  GOTO   2BE (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
01A9:  DECFSZ 4E,W
01AA:  GOTO   1AC
01AB:  GOTO   1AF
....................       address=LCD_LINE_TWO; 
01AC:  MOVLW  40
01AD:  MOVWF  4F
01AE:  GOTO   1B0
....................    else 
....................       address=0; 
01AF:  CLRF   4F
....................       
....................    address+=x-1; 
01B0:  MOVLW  01
01B1:  SUBWF  4D,W
01B2:  ADDWF  4F,F
....................    lcd_send_byte(0,0x80|address); 
01B3:  MOVF   4F,W
01B4:  IORLW  80
01B5:  MOVWF  50
01B6:  CLRF   51
01B7:  MOVF   50,W
01B8:  MOVWF  52
01B9:  CALL   12B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01BA:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01BB:  MOVF   4C,W
01BC:  XORLW  07
01BD:  BTFSC  03.2
01BE:  GOTO   1C9
01BF:  XORLW  0B
01C0:  BTFSC  03.2
01C1:  GOTO   1CE
01C2:  XORLW  06
01C3:  BTFSC  03.2
01C4:  GOTO   1D6
01C5:  XORLW  02
01C6:  BTFSC  03.2
01C7:  GOTO   1DC
01C8:  GOTO   1E1
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01C9:  MOVLW  01
01CA:  MOVWF  4D
01CB:  MOVWF  4E
01CC:  CALL   1A9
01CD:  GOTO   1E6
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01CE:  CLRF   51
01CF:  MOVLW  01
01D0:  MOVWF  52
01D1:  CALL   12B
....................                      delay_ms(2); 
01D2:  MOVLW  02
01D3:  MOVWF  4D
01D4:  CALL   104
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01D5:  GOTO   1E6
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01D6:  MOVLW  01
01D7:  MOVWF  4D
01D8:  MOVLW  02
01D9:  MOVWF  4E
01DA:  CALL   1A9
01DB:  GOTO   1E6
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01DC:  CLRF   51
01DD:  MOVLW  10
01DE:  MOVWF  52
01DF:  CALL   12B
01E0:  GOTO   1E6
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01E1:  MOVLW  01
01E2:  MOVWF  51
01E3:  MOVF   4C,W
01E4:  MOVWF  52
01E5:  CALL   12B
....................      #endif 
....................    } 
01E6:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include<DHT11.c> 
.................... /* #include <DHT11.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 10/04/2019 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AB7:  BCF    03.6
0AB8:  CLRF   21
0AB9:  CLRF   22
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
04C1:  CLRF   55
04C2:  CLRF   54
04C3:  CLRF   53
04C4:  MOVLW  7F
04C5:  MOVWF  52
04C6:  CLRF   59
04C7:  CLRF   58
04C8:  CLRF   57
04C9:  CLRF   56
04CA:  BSF    5A.0
04CB:  BCF    5A.1
04CC:  BCF    5A.2
04CD:  CLRF   5C
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
04CE:  MOVF   4E,W
04CF:  IORWF  4F,W
04D0:  BTFSS  03.2
04D1:  GOTO   4D7
....................       return 0; 
04D2:  CLRF   77
04D3:  CLRF   78
04D4:  CLRF   79
04D5:  CLRF   7A
04D6:  GOTO   6AA
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
04D7:  MOVF   5C,W
04D8:  INCF   5C,F
04D9:  ADDWF  4E,W
04DA:  MOVWF  04
04DB:  BCF    03.7
04DC:  BTFSC  4F.0
04DD:  BSF    03.7
04DE:  MOVF   00,W
04DF:  MOVWF  5B
04E0:  MOVF   5B,F
04E1:  BTFSC  03.2
04E2:  GOTO   668
....................    { 
....................       if (skip && !isspace(c)) 
04E3:  BTFSS  5A.0
04E4:  GOTO   4F7
04E5:  MOVF   5B,W
04E6:  SUBLW  20
04E7:  BTFSC  03.2
04E8:  GOTO   4F7
....................       { 
....................          skip = 0; 
04E9:  BCF    5A.0
....................          if (c == '+') 
04EA:  MOVF   5B,W
04EB:  SUBLW  2B
04EC:  BTFSS  03.2
04ED:  GOTO   4F1
....................          { 
....................             sign = 0; 
04EE:  BCF    5A.1
....................             continue; 
04EF:  GOTO   65E
....................          }             
04F0:  GOTO   4F7
....................          else if (c == '-') 
04F1:  MOVF   5B,W
04F2:  SUBLW  2D
04F3:  BTFSS  03.2
04F4:  GOTO   4F7
....................          { 
....................             sign = 1; 
04F5:  BSF    5A.1
....................             continue; 
04F6:  GOTO   65E
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
04F7:  BTFSC  5A.0
04F8:  GOTO   501
04F9:  MOVF   5B,W
04FA:  SUBLW  2E
04FB:  BTFSS  03.2
04FC:  GOTO   501
04FD:  BTFSC  5A.2
04FE:  GOTO   501
....................          point = 1; 
04FF:  BSF    5A.2
0500:  GOTO   65E
....................       else if (!skip && isdigit(c)) 
0501:  BTFSC  5A.0
0502:  GOTO   65C
0503:  MOVF   5B,W
0504:  SUBLW  2F
0505:  BTFSC  03.0
0506:  GOTO   65C
0507:  MOVF   5B,W
0508:  SUBLW  39
0509:  BTFSS  03.0
050A:  GOTO   65C
....................       { 
....................          c -= '0'; 
050B:  MOVLW  30
050C:  SUBWF  5B,F
....................          if (point) 
050D:  BTFSS  5A.2
050E:  GOTO   626
....................          { 
....................             pow10 = pow10 * 10.0; 
050F:  MOVF   55,W
0510:  MOVWF  60
0511:  MOVF   54,W
0512:  MOVWF  5F
0513:  MOVF   53,W
0514:  MOVWF  5E
0515:  MOVF   52,W
0516:  MOVWF  5D
0517:  CLRF   64
0518:  CLRF   63
0519:  MOVLW  20
051A:  MOVWF  62
051B:  MOVLW  82
051C:  MOVWF  61
051D:  CALL   2EE
051E:  MOVF   7A,W
051F:  MOVWF  55
0520:  MOVF   79,W
0521:  MOVWF  54
0522:  MOVF   78,W
0523:  MOVWF  53
0524:  MOVF   77,W
0525:  MOVWF  52
....................             result += (float)c / pow10;    
0526:  CLRF   62
0527:  MOVF   5B,W
0528:  MOVWF  61
0529:  CALL   363
052A:  MOVF   7A,W
052B:  MOVWF  60
052C:  MOVF   79,W
052D:  MOVWF  5F
052E:  MOVF   78,W
052F:  MOVWF  5E
0530:  MOVF   77,W
0531:  MOVWF  5D
0532:  MOVF   60,W
0533:  MOVWF  64
0534:  MOVF   5F,W
0535:  MOVWF  63
0536:  MOVF   5E,W
0537:  MOVWF  62
0538:  MOVF   5D,W
0539:  MOVWF  61
053A:  MOVF   55,W
053B:  MOVWF  68
053C:  MOVF   54,W
053D:  MOVWF  67
053E:  MOVF   53,W
053F:  MOVWF  66
0540:  MOVF   52,W
0541:  MOVWF  65
*
060B:  BCF    03.1
060C:  MOVF   59,W
060D:  MOVWF  64
060E:  MOVF   58,W
060F:  MOVWF  63
0610:  MOVF   57,W
0611:  MOVWF  62
0612:  MOVF   56,W
0613:  MOVWF  61
0614:  MOVF   7A,W
0615:  MOVWF  68
0616:  MOVF   79,W
0617:  MOVWF  67
0618:  MOVF   78,W
0619:  MOVWF  66
061A:  MOVF   77,W
061B:  MOVWF  65
061C:  CALL   380
061D:  MOVF   7A,W
061E:  MOVWF  59
061F:  MOVF   79,W
0620:  MOVWF  58
0621:  MOVF   78,W
0622:  MOVWF  57
0623:  MOVF   77,W
0624:  MOVWF  56
....................          } 
0625:  GOTO   65B
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0626:  CLRF   60
0627:  CLRF   5F
0628:  MOVLW  20
0629:  MOVWF  5E
062A:  MOVLW  82
062B:  MOVWF  5D
062C:  MOVF   59,W
062D:  MOVWF  64
062E:  MOVF   58,W
062F:  MOVWF  63
0630:  MOVF   57,W
0631:  MOVWF  62
0632:  MOVF   56,W
0633:  MOVWF  61
0634:  CALL   2EE
0635:  MOVF   7A,W
0636:  MOVWF  60
0637:  MOVF   79,W
0638:  MOVWF  5F
0639:  MOVF   78,W
063A:  MOVWF  5E
063B:  MOVF   77,W
063C:  MOVWF  5D
063D:  CLRF   62
063E:  MOVF   5B,W
063F:  MOVWF  61
0640:  CALL   363
0641:  BCF    03.1
0642:  MOVF   60,W
0643:  MOVWF  64
0644:  MOVF   5F,W
0645:  MOVWF  63
0646:  MOVF   5E,W
0647:  MOVWF  62
0648:  MOVF   5D,W
0649:  MOVWF  61
064A:  MOVF   7A,W
064B:  MOVWF  68
064C:  MOVF   79,W
064D:  MOVWF  67
064E:  MOVF   78,W
064F:  MOVWF  66
0650:  MOVF   77,W
0651:  MOVWF  65
0652:  CALL   380
0653:  MOVF   7A,W
0654:  MOVWF  59
0655:  MOVF   79,W
0656:  MOVWF  58
0657:  MOVF   78,W
0658:  MOVWF  57
0659:  MOVF   77,W
065A:  MOVWF  56
....................          } 
....................       } 
065B:  GOTO   65E
....................       else if (!skip) 
065C:  BTFSS  5A.0
....................          break; 
065D:  GOTO   668
065E:  MOVF   5C,W
065F:  INCF   5C,F
0660:  ADDWF  4E,W
0661:  MOVWF  04
0662:  BCF    03.7
0663:  BTFSC  4F.0
0664:  BSF    03.7
0665:  MOVF   00,W
0666:  MOVWF  5B
0667:  GOTO   4E0
....................    } 
....................  
....................    if (sign) 
0668:  BTFSS  5A.1
0669:  GOTO   681
....................       result = -1*result; 
066A:  CLRF   60
066B:  CLRF   5F
066C:  MOVLW  80
066D:  MOVWF  5E
066E:  MOVLW  7F
066F:  MOVWF  5D
0670:  MOVF   59,W
0671:  MOVWF  64
0672:  MOVF   58,W
0673:  MOVWF  63
0674:  MOVF   57,W
0675:  MOVWF  62
0676:  MOVF   56,W
0677:  MOVWF  61
0678:  CALL   2EE
0679:  MOVF   7A,W
067A:  MOVWF  59
067B:  MOVF   79,W
067C:  MOVWF  58
067D:  MOVF   78,W
067E:  MOVWF  57
067F:  MOVF   77,W
0680:  MOVWF  56
....................        
....................    if(endptr) 
0681:  MOVF   50,W
0682:  IORWF  51,W
0683:  BTFSC  03.2
0684:  GOTO   6A2
....................    { 
....................       if (ptr) { 
0685:  MOVF   5C,F
0686:  BTFSC  03.2
0687:  GOTO   697
....................          ptr--; 
0688:  DECF   5C,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0689:  MOVF   50,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  BTFSC  51.0
068D:  BSF    03.7
068E:  MOVF   5C,W
068F:  ADDWF  4E,W
0690:  MOVWF  00
0691:  INCF   04,F
0692:  MOVF   4F,W
0693:  MOVWF  00
0694:  BTFSC  03.0
0695:  INCF   00,F
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0696:  GOTO   6A2
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0697:  MOVF   50,W
0698:  MOVWF  04
0699:  BCF    03.7
069A:  BTFSC  51.0
069B:  BSF    03.7
069C:  INCF   04,F
069D:  MOVF   4F,W
069E:  MOVWF  00
069F:  DECF   04,F
06A0:  MOVF   4E,W
06A1:  MOVWF  00
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
06A2:  MOVF   56,W
06A3:  MOVWF  77
06A4:  MOVF   57,W
06A5:  MOVWF  78
06A6:  MOVF   58,W
06A7:  MOVWF  79
06A8:  MOVF   59,W
06A9:  MOVWF  7A
06AA:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... int bits[5]; 
....................  
.................... void DHT11_start() 
.................... { 
....................    output_drive(DHT11_PIN); 
*
06AC:  BSF    03.5
06AD:  BCF    05.0
....................    output_low(DHT11_PIN); 
06AE:  BCF    05.0
06AF:  BCF    03.5
06B0:  BCF    05.0
....................    delay_ms(25); 
06B1:  MOVLW  19
06B2:  MOVWF  4D
06B3:  CALL   104
....................    output_high(DHT11_PIN); 
06B4:  BSF    03.5
06B5:  BCF    05.0
06B6:  BCF    03.5
06B7:  BSF    05.0
....................    delay_us(30); 
06B8:  MOVLW  09
06B9:  MOVWF  77
06BA:  DECFSZ 77,F
06BB:  GOTO   6BA
06BC:  GOTO   6BD
....................    output_float(DHT11_PIN); 
06BD:  BSF    03.5
06BE:  BSF    05.0
.................... } 
....................  
.................... void DHT11_response() 
.................... { 
....................    while(input_state(DHT11_PIN)){}; 
06BF:  BCF    03.5
06C0:  BTFSC  05.0
06C1:  GOTO   6C0
....................    while(!input_state(DHT11_PIN)){}; 
06C2:  BTFSS  05.0
06C3:  GOTO   6C2
....................    while(input_state(DHT11_PIN)){};   
06C4:  BTFSC  05.0
06C5:  GOTO   6C4
.................... } 
....................  
.................... int DHT11_read_byte() 
*
0258:  CLRF   4D
.................... { 
....................    int i,data = 0;   
....................    for(i=0;i<8;i++){         
0259:  CLRF   4C
025A:  MOVF   4C,W
025B:  SUBLW  07
025C:  BTFSS  03.0
025D:  GOTO   272
....................       while(!input_state(DHT11_PIN)){ 
025E:  BTFSS  05.0
025F:  GOTO   25E
....................       } 
....................       delay_us(30);          
0260:  MOVLW  09
0261:  MOVWF  77
0262:  DECFSZ 77,F
0263:  GOTO   262
0264:  GOTO   265
....................       if(input_state(DHT11_PIN)){   
0265:  BTFSS  05.0
0266:  GOTO   26C
....................          data = ((data<<1) | 1);  
0267:  BCF    03.0
0268:  RLF    4D,W
0269:  IORLW  01
026A:  MOVWF  4D
....................       } 
026B:  GOTO   26E
....................       else{ 
....................          data = (data<<1);   
026C:  BCF    03.0
026D:  RLF    4D,F
....................       } 
....................       while(input_state(DHT11_PIN)){ 
026E:  BTFSC  05.0
026F:  GOTO   26E
....................       } 
0270:  INCF   4C,F
0271:  GOTO   25A
....................    } 
....................    return data; 
0272:  MOVF   4D,W
0273:  MOVWF  78
0274:  RETURN
.................... } 
....................  
.................... int DHT11_read_data(float *hum, float *temp) 
*
06AB:  CLRF   4B
.................... { 
....................    char buf[8]; 
....................    int result = 0; 
....................    DHT11_start(); 
....................    DHT11_response(); 
....................    bits[0] = DHT11_read_byte();   //Humedad entero 
*
06C6:  CALL   258
06C7:  MOVF   78,W
06C8:  MOVWF  27
....................    bits[1] = DHT11_read_byte();   //Humedad decimal 
06C9:  CALL   258
06CA:  MOVF   78,W
06CB:  MOVWF  28
....................    bits[2] = DHT11_read_byte();   //Temp entero 
06CC:  CALL   258
06CD:  MOVF   78,W
06CE:  MOVWF  29
....................    bits[3] = DHT11_read_byte();   //Temp decimal 
06CF:  CALL   258
06D0:  MOVF   78,W
06D1:  MOVWF  2A
....................    bits[4] = DHT11_read_byte();   //Paridad 
06D2:  CALL   258
06D3:  MOVF   78,W
06D4:  MOVWF  2B
....................    result = bits[0] + bits[1] + bits[2] + bits[3]; 
06D5:  MOVF   28,W
06D6:  ADDWF  27,W
06D7:  ADDWF  29,W
06D8:  ADDWF  2A,W
06D9:  MOVWF  4B
....................    if (result == bits[4]){ 
06DA:  MOVF   2B,W
06DB:  SUBWF  4B,W
06DC:  BTFSS  03.2
06DD:  GOTO   73A
....................       sprintf(buf, "%2d.%1d",bits[0],bits[1]); 
06DE:  CLRF   2D
06DF:  MOVLW  43
06E0:  MOVWF  2C
06E1:  MOVF   27,W
06E2:  MOVWF  4C
06E3:  MOVLW  11
06E4:  MOVWF  4D
06E5:  CALL   297
06E6:  MOVLW  2E
06E7:  MOVWF  52
06E8:  CALL   28A
06E9:  MOVF   28,W
06EA:  MOVWF  4C
06EB:  MOVLW  18
06EC:  MOVWF  4D
06ED:  CALL   297
....................       *hum = atof(buf); 
06EE:  MOVF   40,W
06EF:  MOVWF  7A
06F0:  MOVF   3F,W
06F1:  MOVWF  4C
06F2:  MOVF   40,W
06F3:  MOVWF  4D
06F4:  CLRF   4F
06F5:  MOVLW  43
06F6:  MOVWF  4E
06F7:  CLRF   51
06F8:  CLRF   50
06F9:  CALL   4C1
06FA:  MOVF   4C,W
06FB:  MOVWF  04
06FC:  BCF    03.7
06FD:  BTFSC  4D.0
06FE:  BSF    03.7
06FF:  MOVF   77,W
0700:  MOVWF  00
0701:  INCF   04,F
0702:  MOVF   78,W
0703:  MOVWF  00
0704:  INCF   04,F
0705:  MOVF   79,W
0706:  MOVWF  00
0707:  INCF   04,F
0708:  MOVF   7A,W
0709:  MOVWF  00
....................       sprintf(buf, "%2d.%1d",bits[2],bits[3]); 
070A:  CLRF   2D
070B:  MOVLW  43
070C:  MOVWF  2C
070D:  MOVF   29,W
070E:  MOVWF  4C
070F:  MOVLW  11
0710:  MOVWF  4D
0711:  CALL   297
0712:  MOVLW  2E
0713:  MOVWF  52
0714:  CALL   28A
0715:  MOVF   2A,W
0716:  MOVWF  4C
0717:  MOVLW  18
0718:  MOVWF  4D
0719:  CALL   297
....................       *temp = atof(buf);   
071A:  MOVF   42,W
071B:  MOVWF  7A
071C:  MOVF   41,W
071D:  MOVWF  4C
071E:  MOVF   42,W
071F:  MOVWF  4D
0720:  CLRF   4F
0721:  MOVLW  43
0722:  MOVWF  4E
0723:  CLRF   51
0724:  CLRF   50
0725:  CALL   4C1
0726:  MOVF   4C,W
0727:  MOVWF  04
0728:  BCF    03.7
0729:  BTFSC  4D.0
072A:  BSF    03.7
072B:  MOVF   77,W
072C:  MOVWF  00
072D:  INCF   04,F
072E:  MOVF   78,W
072F:  MOVWF  00
0730:  INCF   04,F
0731:  MOVF   79,W
0732:  MOVWF  00
0733:  INCF   04,F
0734:  MOVF   7A,W
0735:  MOVWF  00
....................       return 1; 
0736:  MOVLW  01
0737:  MOVWF  78
0738:  GOTO   73C
....................    } 
0739:  GOTO   73C
....................    else{ 
....................       return 0; 
073A:  MOVLW  00
073B:  MOVWF  78
....................    } 
073C:  RETURN
.................... } 
....................  
.................... //Consntantes de conversion 
.................... #define faCentigrados 0.55555555555555555555555555 
....................  
.................... void main(){ 
*
0A8F:  MOVF   03,W
0A90:  ANDLW  1F
0A91:  MOVWF  03
0A92:  MOVLW  61
0A93:  BSF    03.5
0A94:  MOVWF  0F
0A95:  MOVF   0F,W
0A96:  BCF    03.5
0A97:  CLRF   20
0A98:  BSF    03.5
0A99:  BSF    03.6
0A9A:  BCF    07.3
0A9B:  MOVLW  19
0A9C:  BCF    03.6
0A9D:  MOVWF  19
0A9E:  MOVLW  A6
0A9F:  MOVWF  18
0AA0:  MOVLW  90
0AA1:  BCF    03.5
0AA2:  MOVWF  18
0AA3:  CLRF   2D
0AA4:  CLRF   2C
0AA5:  MOVLW  FF
0AA6:  MOVWF  2E
0AA7:  BSF    03.5
0AA8:  BSF    03.6
0AA9:  MOVF   09,W
0AAA:  ANDLW  C0
0AAB:  MOVWF  09
0AAC:  BCF    03.6
0AAD:  BCF    1F.4
0AAE:  BCF    1F.5
0AAF:  MOVLW  00
0AB0:  BSF    03.6
0AB1:  MOVWF  08
0AB2:  BCF    03.5
0AB3:  CLRF   07
0AB4:  CLRF   08
0AB5:  CLRF   09
0AB6:  BCF    03.7
*
0ABA:  CLRF   2F
0ABB:  CLRF   30
....................    //Variable donde se almacenara el valor del ADC de los sensores de peruta y temperatura respectivamente 
....................    int puerta = 0, data_ok = 0; 
....................    float temperatura,centigrados, humedad; 
....................    char modo; 
....................     
....................    // variable para salir de un modo 
....................    char salir; 
....................    // se inicializa la funcion del LCD 
....................    lcd_init();  
0ABC:  BCF    0A.3
0ABD:  GOTO   16B
0ABE:  BSF    0A.3
....................     
....................     
....................    //Imprimir mensaje de preparacion en la LCD 
....................    lcd_putc("\fReady...\n"); 
0ABF:  MOVLW  04
0AC0:  BSF    03.6
0AC1:  MOVWF  0D
0AC2:  MOVLW  00
0AC3:  MOVWF  0F
0AC4:  BCF    0A.3
0AC5:  BCF    03.6
0AC6:  CALL   1E7
0AC7:  BSF    0A.3
....................    delay_ms(2000); 
0AC8:  MOVLW  08
0AC9:  MOVWF  3F
0ACA:  MOVLW  FA
0ACB:  MOVWF  4D
0ACC:  BCF    0A.3
0ACD:  CALL   104
0ACE:  BSF    0A.3
0ACF:  DECFSZ 3F,F
0AD0:  GOTO   2CA
....................    //Comienzo del programa 
....................    while(TRUE) 
....................    {      
....................       //Limpiar la LCD 
....................       printf(lcd_putc, "\f"); 
0AD1:  MOVLW  0C
0AD2:  MOVWF  4C
0AD3:  BCF    0A.3
0AD4:  CALL   1BB
0AD5:  BSF    0A.3
....................        
....................       //Solicitud de Modo de trabajo 
....................       while(true) 
....................       { 
....................          printf(lcd_putc,"\f"); 
0AD6:  MOVLW  0C
0AD7:  MOVWF  4C
0AD8:  BCF    0A.3
0AD9:  CALL   1BB
0ADA:  BSF    0A.3
....................          printf("\n\r"); 
0ADB:  MOVLW  0A
0ADC:  BTFSS  0C.4
0ADD:  GOTO   2DC
0ADE:  MOVWF  19
0ADF:  MOVLW  0D
0AE0:  BTFSS  0C.4
0AE1:  GOTO   2E0
0AE2:  MOVWF  19
....................          //apagar los actuadores 
....................          //ventilador       
....................          output_low(PIN_C1); 
0AE3:  BCF    2E.1
0AE4:  MOVF   2E,W
0AE5:  BSF    03.5
0AE6:  MOVWF  07
0AE7:  BCF    03.5
0AE8:  BCF    07.1
....................          output_low(PIN_C2); 
0AE9:  BCF    2E.2
0AEA:  MOVF   2E,W
0AEB:  BSF    03.5
0AEC:  MOVWF  07
0AED:  BCF    03.5
0AEE:  BCF    07.2
....................          puerta = 0; 
0AEF:  CLRF   2F
....................          //led de advertencia 
....................          output_low(PIN_C0); 
0AF0:  BCF    2E.0
0AF1:  MOVF   2E,W
0AF2:  BSF    03.5
0AF3:  MOVWF  07
0AF4:  BCF    03.5
0AF5:  BCF    07.0
....................          lcd_gotoxy(1,1); 
0AF6:  MOVLW  01
0AF7:  MOVWF  4D
0AF8:  MOVWF  4E
0AF9:  BCF    0A.3
0AFA:  CALL   1A9
0AFB:  BSF    0A.3
....................          printf(lcd_putc,"Seleccion modo"); 
0AFC:  MOVLW  0A
0AFD:  BSF    03.6
0AFE:  MOVWF  0D
0AFF:  MOVLW  00
0B00:  MOVWF  0F
0B01:  BCF    0A.3
0B02:  BCF    03.6
0B03:  CALL   1E7
0B04:  BSF    0A.3
....................          lcd_gotoxy(1,2); 
0B05:  MOVLW  01
0B06:  MOVWF  4D
0B07:  MOVLW  02
0B08:  MOVWF  4E
0B09:  BCF    0A.3
0B0A:  CALL   1A9
0B0B:  BSF    0A.3
....................          printf(lcd_putc,"a:Auto | b:Man"); 
0B0C:  MOVLW  12
0B0D:  BSF    03.6
0B0E:  MOVWF  0D
0B0F:  MOVLW  00
0B10:  MOVWF  0F
0B11:  BCF    0A.3
0B12:  BCF    03.6
0B13:  CALL   1E7
0B14:  BSF    0A.3
....................          //ingreso de modo de trabajo 
....................          modo = getch(); 
0B15:  BCF    0A.3
0B16:  CALL   23D
0B17:  BSF    0A.3
0B18:  MOVF   78,W
0B19:  MOVWF  3D
....................          if(modo == 'a' || modo == 'b'){ 
0B1A:  MOVF   3D,W
0B1B:  SUBLW  61
0B1C:  BTFSC  03.2
0B1D:  GOTO   321
0B1E:  MOVF   3D,W
0B1F:  SUBLW  62
0B20:  BTFSC  03.2
....................             break; 
0B21:  GOTO   32C
....................          } 
....................           
....................          delay_ms(500); 
0B22:  MOVLW  02
0B23:  MOVWF  3F
0B24:  MOVLW  FA
0B25:  MOVWF  4D
0B26:  BCF    0A.3
0B27:  CALL   104
0B28:  BSF    0A.3
0B29:  DECFSZ 3F,F
0B2A:  GOTO   324
0B2B:  GOTO   2D6
....................       } 
....................        
....................       //En caso de modo A: ADC 
....................       switch(modo){ 
0B2C:  MOVF   3D,W
0B2D:  XORLW  61
0B2E:  BTFSC  03.2
0B2F:  GOTO   334
0B30:  XORLW  03
0B31:  BTFSC  03.2
0B32:  GOTO   566
0B33:  GOTO   7AD
....................          case 'a': 
....................          { 
....................              
....................             while(true) 
....................             { 
....................                //lectura de temperatura 
....................                data_ok = DHT11_read_data(&temperatura,&humedad); 
0B34:  CLRF   40
0B35:  MOVLW  31
0B36:  MOVWF  3F
0B37:  CLRF   42
0B38:  MOVLW  39
0B39:  MOVWF  41
0B3A:  BCF    0A.3
0B3B:  CALL   6AB
0B3C:  BSF    0A.3
0B3D:  MOVF   78,W
0B3E:  MOVWF  30
....................                //lectura de puerta 
....................                puerta = input(spuerta); 
0B3F:  BSF    03.5
0B40:  BSF    05.1
0B41:  BCF    03.5
0B42:  CLRF   2F
0B43:  BTFSC  05.1
0B44:  INCF   2F,F
....................                //Imprimir en LCD 
....................                printf(lcd_putc, "\f"); 
0B45:  MOVLW  0C
0B46:  MOVWF  4C
0B47:  BCF    0A.3
0B48:  CALL   1BB
0B49:  BSF    0A.3
....................                lcd_gotoxy(1,1); 
0B4A:  MOVLW  01
0B4B:  MOVWF  4D
0B4C:  MOVWF  4E
0B4D:  BCF    0A.3
0B4E:  CALL   1A9
0B4F:  BSF    0A.3
....................                printf(lcd_putc, "m:Auto"); 
0B50:  MOVLW  1A
0B51:  BSF    03.6
0B52:  MOVWF  0D
0B53:  MOVLW  00
0B54:  MOVWF  0F
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  CALL   1E7
0B58:  BSF    0A.3
....................                if(puerta == 0){ 
0B59:  MOVF   2F,F
0B5A:  BTFSS  03.2
0B5B:  GOTO   36D
....................                   lcd_gotoxy(8,1); 
0B5C:  MOVLW  08
0B5D:  MOVWF  4D
0B5E:  MOVLW  01
0B5F:  MOVWF  4E
0B60:  BCF    0A.3
0B61:  CALL   1A9
0B62:  BSF    0A.3
....................                   printf(lcd_putc, "Pue:Clo\n\r"); 
0B63:  MOVLW  1E
0B64:  BSF    03.6
0B65:  MOVWF  0D
0B66:  MOVLW  00
0B67:  MOVWF  0F
0B68:  BCF    0A.3
0B69:  BCF    03.6
0B6A:  CALL   1E7
0B6B:  BSF    0A.3
....................                }else{ 
0B6C:  GOTO   37D
....................                   lcd_gotoxy(8,1); 
0B6D:  MOVLW  08
0B6E:  MOVWF  4D
0B6F:  MOVLW  01
0B70:  MOVWF  4E
0B71:  BCF    0A.3
0B72:  CALL   1A9
0B73:  BSF    0A.3
....................                   printf(lcd_putc, "Pue:Ope"); 
0B74:  MOVLW  23
0B75:  BSF    03.6
0B76:  MOVWF  0D
0B77:  MOVLW  00
0B78:  MOVWF  0F
0B79:  BCF    0A.3
0B7A:  BCF    03.6
0B7B:  CALL   1E7
0B7C:  BSF    0A.3
....................                } 
....................                //Lectura de temperatura 
....................                if(data_ok == 1) 
0B7D:  DECFSZ 30,W
0B7E:  GOTO   537
....................                { 
....................                   //calculo de grados centigrados 
....................                   centigrados = (temperatura - 32)*faCentigrados; 
0B7F:  BSF    03.1
0B80:  MOVF   34,W
0B81:  MOVWF  64
0B82:  MOVF   33,W
0B83:  MOVWF  63
0B84:  MOVF   32,W
0B85:  MOVWF  62
0B86:  MOVF   31,W
0B87:  MOVWF  61
0B88:  CLRF   68
0B89:  CLRF   67
0B8A:  CLRF   66
0B8B:  MOVLW  84
0B8C:  MOVWF  65
0B8D:  BCF    0A.3
0B8E:  CALL   380
0B8F:  BSF    0A.3
0B90:  MOVF   7A,W
0B91:  MOVWF  42
0B92:  MOVF   79,W
0B93:  MOVWF  41
0B94:  MOVF   78,W
0B95:  MOVWF  40
0B96:  MOVF   77,W
0B97:  MOVWF  3F
0B98:  MOVF   7A,W
0B99:  MOVWF  60
0B9A:  MOVF   79,W
0B9B:  MOVWF  5F
0B9C:  MOVF   78,W
0B9D:  MOVWF  5E
0B9E:  MOVF   77,W
0B9F:  MOVWF  5D
0BA0:  MOVLW  E4
0BA1:  MOVWF  64
0BA2:  MOVLW  38
0BA3:  MOVWF  63
0BA4:  MOVLW  0E
0BA5:  MOVWF  62
0BA6:  MOVLW  7E
0BA7:  MOVWF  61
0BA8:  BCF    0A.3
0BA9:  CALL   2EE
0BAA:  BSF    0A.3
0BAB:  MOVF   7A,W
0BAC:  MOVWF  38
0BAD:  MOVF   79,W
0BAE:  MOVWF  37
0BAF:  MOVF   78,W
0BB0:  MOVWF  36
0BB1:  MOVF   77,W
0BB2:  MOVWF  35
....................                   //salidas 
....................                   lcd_gotoxy(1,2); 
0BB3:  MOVLW  01
0BB4:  MOVWF  4D
0BB5:  MOVLW  02
0BB6:  MOVWF  4E
0BB7:  BCF    0A.3
0BB8:  CALL   1A9
0BB9:  BSF    0A.3
....................                   printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0BBA:  MOVLW  54
0BBB:  MOVWF  4C
0BBC:  BCF    0A.3
0BBD:  CALL   1BB
0BBE:  BSF    0A.3
0BBF:  MOVLW  3A
0BC0:  MOVWF  4C
0BC1:  BCF    0A.3
0BC2:  CALL   1BB
0BC3:  BSF    0A.3
0BC4:  MOVLW  20
0BC5:  MOVWF  4C
0BC6:  BCF    0A.3
0BC7:  CALL   1BB
0BC8:  BSF    0A.3
0BC9:  MOVLW  89
0BCA:  MOVWF  04
0BCB:  MOVF   38,W
0BCC:  MOVWF  42
0BCD:  MOVF   37,W
0BCE:  MOVWF  41
0BCF:  MOVF   36,W
0BD0:  MOVWF  40
0BD1:  MOVF   35,W
0BD2:  MOVWF  3F
0BD3:  MOVLW  01
0BD4:  MOVWF  43
0BD5:  CALL   000
0BD6:  MOVLW  20
0BD7:  MOVWF  4C
0BD8:  BCF    0A.3
0BD9:  CALL   1BB
0BDA:  BSF    0A.3
0BDB:  MOVLW  DF
0BDC:  MOVWF  4C
0BDD:  BCF    0A.3
0BDE:  CALL   1BB
0BDF:  BSF    0A.3
0BE0:  MOVLW  43
0BE1:  MOVWF  4C
0BE2:  BCF    0A.3
0BE3:  CALL   1BB
0BE4:  BSF    0A.3
....................                   // calculos de temperatura 
....................                   if (centigrados >= 15 && centigrados <= 30 && puerta == 1) { 
0BE5:  CLRF   42
0BE6:  CLRF   41
0BE7:  MOVLW  70
0BE8:  MOVWF  40
0BE9:  MOVLW  82
0BEA:  MOVWF  3F
0BEB:  MOVF   38,W
0BEC:  MOVWF  46
0BED:  MOVF   37,W
0BEE:  MOVWF  45
0BEF:  MOVF   36,W
0BF0:  MOVWF  44
0BF1:  MOVF   35,W
0BF2:  MOVWF  43
0BF3:  BCF    0A.3
0BF4:  CALL   7AB
0BF5:  BSF    0A.3
0BF6:  BTFSC  03.0
0BF7:  GOTO   3FA
0BF8:  BTFSS  03.2
0BF9:  GOTO   46C
0BFA:  MOVF   38,W
0BFB:  MOVWF  42
0BFC:  MOVF   37,W
0BFD:  MOVWF  41
0BFE:  MOVF   36,W
0BFF:  MOVWF  40
0C00:  MOVF   35,W
0C01:  MOVWF  3F
0C02:  CLRF   46
0C03:  CLRF   45
0C04:  MOVLW  70
0C05:  MOVWF  44
0C06:  MOVLW  83
0C07:  MOVWF  43
0C08:  BCF    0A.3
0C09:  CALL   7AB
0C0A:  BSF    0A.3
0C0B:  BTFSC  03.0
0C0C:  GOTO   40F
0C0D:  BTFSS  03.2
0C0E:  GOTO   46C
0C0F:  DECFSZ 2F,W
0C10:  GOTO   46C
....................                      //ventilador       
....................                      output_high(PIN_C1); 
0C11:  BCF    2E.1
0C12:  MOVF   2E,W
0C13:  BSF    03.5
0C14:  MOVWF  07
0C15:  BCF    03.5
0C16:  BSF    07.1
....................                      output_low(PIN_C2); 
0C17:  BCF    2E.2
0C18:  MOVF   2E,W
0C19:  BSF    03.5
0C1A:  MOVWF  07
0C1B:  BCF    03.5
0C1C:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0C1D:  MOVLW  0C
0C1E:  MOVWF  4D
0C1F:  MOVLW  02
0C20:  MOVWF  4E
0C21:  BCF    0A.3
0C22:  CALL   1A9
0C23:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0C24:  MOVLW  27
0C25:  BSF    03.6
0C26:  MOVWF  0D
0C27:  MOVLW  00
0C28:  MOVWF  0F
0C29:  BCF    0A.3
0C2A:  BCF    03.6
0C2B:  CALL   1E7
0C2C:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f %c   |   Puerta: %u   |   Ventilador: ON\n\r",centigrados ,223, puerta); 
0C2D:  MOVLW  2A
0C2E:  BSF    03.6
0C2F:  MOVWF  0D
0C30:  MOVLW  00
0C31:  MOVWF  0F
0C32:  BCF    03.0
0C33:  MOVLW  11
0C34:  BCF    03.6
0C35:  MOVWF  3F
0C36:  CALL   0D3
0C37:  MOVLW  89
0C38:  MOVWF  04
0C39:  MOVF   38,W
0C3A:  MOVWF  42
0C3B:  MOVF   37,W
0C3C:  MOVWF  41
0C3D:  MOVF   36,W
0C3E:  MOVWF  40
0C3F:  MOVF   35,W
0C40:  MOVWF  3F
0C41:  MOVLW  01
0C42:  MOVWF  43
0C43:  CALL   12C
0C44:  MOVLW  20
0C45:  BTFSS  0C.4
0C46:  GOTO   445
0C47:  MOVWF  19
0C48:  MOVLW  DF
0C49:  BTFSS  0C.4
0C4A:  GOTO   449
0C4B:  MOVWF  19
0C4C:  MOVLW  36
0C4D:  BSF    03.6
0C4E:  MOVWF  0D
0C4F:  MOVLW  00
0C50:  MOVWF  0F
0C51:  BCF    03.0
0C52:  MOVLW  0F
0C53:  BCF    03.6
0C54:  MOVWF  3F
0C55:  CALL   0D3
0C56:  MOVF   2F,W
0C57:  MOVWF  3F
0C58:  MOVLW  1B
0C59:  MOVWF  40
0C5A:  CALL   1FB
0C5B:  MOVLW  3E
0C5C:  BSF    03.6
0C5D:  MOVWF  0D
0C5E:  MOVLW  00
0C5F:  MOVWF  0F
0C60:  BSF    03.0
0C61:  MOVLW  17
0C62:  BCF    03.6
0C63:  MOVWF  3F
0C64:  CALL   0D3
....................                      //led de advertencia 
....................                      output_low(PIN_C0); 
0C65:  BCF    2E.0
0C66:  MOVF   2E,W
0C67:  BSF    03.5
0C68:  MOVWF  07
0C69:  BCF    03.5
0C6A:  BCF    07.0
....................                   } else if (centigrados > 30 && puerta == 1) { 
0C6B:  GOTO   536
0C6C:  CLRF   42
0C6D:  CLRF   41
0C6E:  MOVLW  70
0C6F:  MOVWF  40
0C70:  MOVLW  83
0C71:  MOVWF  3F
0C72:  MOVF   38,W
0C73:  MOVWF  46
0C74:  MOVF   37,W
0C75:  MOVWF  45
0C76:  MOVF   36,W
0C77:  MOVWF  44
0C78:  MOVF   35,W
0C79:  MOVWF  43
0C7A:  BCF    0A.3
0C7B:  CALL   7AB
0C7C:  BSF    0A.3
0C7D:  BTFSS  03.0
0C7E:  GOTO   4DC
0C7F:  DECFSZ 2F,W
0C80:  GOTO   4DC
....................                      //ventilador       
....................                      output_high(PIN_C1); 
0C81:  BCF    2E.1
0C82:  MOVF   2E,W
0C83:  BSF    03.5
0C84:  MOVWF  07
0C85:  BCF    03.5
0C86:  BSF    07.1
....................                      output_low(PIN_C2); 
0C87:  BCF    2E.2
0C88:  MOVF   2E,W
0C89:  BSF    03.5
0C8A:  MOVWF  07
0C8B:  BCF    03.5
0C8C:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0C8D:  MOVLW  0C
0C8E:  MOVWF  4D
0C8F:  MOVLW  02
0C90:  MOVWF  4E
0C91:  BCF    0A.3
0C92:  CALL   1A9
0C93:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0C94:  MOVLW  4B
0C95:  BSF    03.6
0C96:  MOVWF  0D
0C97:  MOVLW  00
0C98:  MOVWF  0F
0C99:  BCF    0A.3
0C9A:  BCF    03.6
0C9B:  CALL   1E7
0C9C:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f %c(Precaucion)|Puerta: %u|Ventilador: ON\n\r",centigrados ,223, puerta); 
0C9D:  MOVLW  4E
0C9E:  BSF    03.6
0C9F:  MOVWF  0D
0CA0:  MOVLW  00
0CA1:  MOVWF  0F
0CA2:  BCF    03.0
0CA3:  MOVLW  11
0CA4:  BCF    03.6
0CA5:  MOVWF  3F
0CA6:  CALL   0D3
0CA7:  MOVLW  89
0CA8:  MOVWF  04
0CA9:  MOVF   38,W
0CAA:  MOVWF  42
0CAB:  MOVF   37,W
0CAC:  MOVWF  41
0CAD:  MOVF   36,W
0CAE:  MOVWF  40
0CAF:  MOVF   35,W
0CB0:  MOVWF  3F
0CB1:  MOVLW  01
0CB2:  MOVWF  43
0CB3:  CALL   12C
0CB4:  MOVLW  20
0CB5:  BTFSS  0C.4
0CB6:  GOTO   4B5
0CB7:  MOVWF  19
0CB8:  MOVLW  DF
0CB9:  BTFSS  0C.4
0CBA:  GOTO   4B9
0CBB:  MOVWF  19
0CBC:  MOVLW  5A
0CBD:  BSF    03.6
0CBE:  MOVWF  0D
0CBF:  MOVLW  00
0CC0:  MOVWF  0F
0CC1:  BCF    03.0
0CC2:  MOVLW  15
0CC3:  BCF    03.6
0CC4:  MOVWF  3F
0CC5:  CALL   0D3
0CC6:  MOVF   2F,W
0CC7:  MOVWF  3F
0CC8:  MOVLW  1B
0CC9:  MOVWF  40
0CCA:  CALL   1FB
0CCB:  MOVLW  65
0CCC:  BSF    03.6
0CCD:  MOVWF  0D
0CCE:  MOVLW  00
0CCF:  MOVWF  0F
0CD0:  BSF    03.0
0CD1:  MOVLW  11
0CD2:  BCF    03.6
0CD3:  MOVWF  3F
0CD4:  CALL   0D3
....................                      //led de advertencia 
....................                      output_high(PIN_C0); 
0CD5:  BCF    2E.0
0CD6:  MOVF   2E,W
0CD7:  BSF    03.5
0CD8:  MOVWF  07
0CD9:  BCF    03.5
0CDA:  BSF    07.0
....................                   } else { 
0CDB:  GOTO   536
....................                      //ventilador       
....................                      output_low(PIN_C1); 
0CDC:  BCF    2E.1
0CDD:  MOVF   2E,W
0CDE:  BSF    03.5
0CDF:  MOVWF  07
0CE0:  BCF    03.5
0CE1:  BCF    07.1
....................                      output_low(PIN_C2); 
0CE2:  BCF    2E.2
0CE3:  MOVF   2E,W
0CE4:  BSF    03.5
0CE5:  MOVWF  07
0CE6:  BCF    03.5
0CE7:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0CE8:  MOVLW  0C
0CE9:  MOVWF  4D
0CEA:  MOVLW  02
0CEB:  MOVWF  4E
0CEC:  BCF    0A.3
0CED:  CALL   1A9
0CEE:  BSF    0A.3
....................                      printf(lcd_putc, "V:OFF"); 
0CEF:  MOVLW  6F
0CF0:  BSF    03.6
0CF1:  MOVWF  0D
0CF2:  MOVLW  00
0CF3:  MOVWF  0F
0CF4:  BCF    0A.3
0CF5:  BCF    03.6
0CF6:  CALL   1E7
0CF7:  BSF    0A.3
....................                      //Imprimir en puerto serie 
....................                      printf("Temperatura (C): %.1f %c   |   Puerta: %u   |   Ventilador: OFF\n\r",centigrados ,223, puerta); 
0CF8:  MOVLW  72
0CF9:  BSF    03.6
0CFA:  MOVWF  0D
0CFB:  MOVLW  00
0CFC:  MOVWF  0F
0CFD:  BCF    03.0
0CFE:  MOVLW  11
0CFF:  BCF    03.6
0D00:  MOVWF  3F
0D01:  CALL   0D3
0D02:  MOVLW  89
0D03:  MOVWF  04
0D04:  MOVF   38,W
0D05:  MOVWF  42
0D06:  MOVF   37,W
0D07:  MOVWF  41
0D08:  MOVF   36,W
0D09:  MOVWF  40
0D0A:  MOVF   35,W
0D0B:  MOVWF  3F
0D0C:  MOVLW  01
0D0D:  MOVWF  43
0D0E:  CALL   12C
0D0F:  MOVLW  20
0D10:  BTFSS  0C.4
0D11:  GOTO   510
0D12:  MOVWF  19
0D13:  MOVLW  DF
0D14:  BTFSS  0C.4
0D15:  GOTO   514
0D16:  MOVWF  19
0D17:  MOVLW  7E
0D18:  BSF    03.6
0D19:  MOVWF  0D
0D1A:  MOVLW  00
0D1B:  MOVWF  0F
0D1C:  BCF    03.0
0D1D:  MOVLW  0F
0D1E:  BCF    03.6
0D1F:  MOVWF  3F
0D20:  CALL   0D3
0D21:  MOVF   2F,W
0D22:  MOVWF  3F
0D23:  MOVLW  1B
0D24:  MOVWF  40
0D25:  CALL   1FB
0D26:  MOVLW  86
0D27:  BSF    03.6
0D28:  MOVWF  0D
0D29:  MOVLW  00
0D2A:  MOVWF  0F
0D2B:  BSF    03.0
0D2C:  MOVLW  18
0D2D:  BCF    03.6
0D2E:  MOVWF  3F
0D2F:  CALL   0D3
....................                      //led de advertencia 
....................                      output_low(PIN_C0); 
0D30:  BCF    2E.0
0D31:  MOVF   2E,W
0D32:  BSF    03.5
0D33:  MOVWF  07
0D34:  BCF    03.5
0D35:  BCF    07.0
....................                      } 
....................                }else{ 
0D36:  GOTO   54E
....................                   //salidas 
....................                   lcd_gotoxy(1,2); 
0D37:  MOVLW  01
0D38:  MOVWF  4D
0D39:  MOVLW  02
0D3A:  MOVWF  4E
0D3B:  BCF    0A.3
0D3C:  CALL   1A9
0D3D:  BSF    0A.3
....................                   printf(lcd_putc, "T:NA"); 
0D3E:  MOVLW  93
0D3F:  BSF    03.6
0D40:  MOVWF  0D
0D41:  MOVLW  00
0D42:  MOVWF  0F
0D43:  BCF    0A.3
0D44:  BCF    03.6
0D45:  CALL   1E7
0D46:  BSF    0A.3
....................                   printf("DESCONECTADO\n\r"); 
0D47:  MOVLW  96
0D48:  BSF    03.6
0D49:  MOVWF  0D
0D4A:  MOVLW  00
0D4B:  MOVWF  0F
0D4C:  BCF    03.6
0D4D:  CALL   237
....................                } 
....................        
....................                // se reinicia spuerta 
....................                puerta = 0; 
0D4E:  CLRF   2F
....................                //se solicita confirmacion para salir 
....................                salir = getch(); 
0D4F:  BCF    0A.3
0D50:  CALL   23D
0D51:  BSF    0A.3
0D52:  MOVF   78,W
0D53:  MOVWF  3E
....................                if(salir == 's')  
0D54:  MOVF   3E,W
0D55:  SUBLW  73
0D56:  BTFSC  03.2
....................                { 
....................                   break; 
0D57:  GOTO   562
....................                } 
....................               
....................                delay_ms(1500); 
0D58:  MOVLW  06
0D59:  MOVWF  3F
0D5A:  MOVLW  FA
0D5B:  MOVWF  4D
0D5C:  BCF    0A.3
0D5D:  CALL   104
0D5E:  BSF    0A.3
0D5F:  DECFSZ 3F,F
0D60:  GOTO   55A
0D61:  GOTO   334
....................             } 
....................         
....................              
....................          } 
....................           
....................          if(salir == 's') { 
0D62:  MOVF   3E,W
0D63:  SUBLW  73
0D64:  BTFSC  03.2
....................                   break; 
0D65:  GOTO   7AD
....................          } 
....................           
....................          case 'b': 
....................          { 
....................             while(true) 
....................             { 
....................                //repetir lo siguente 
....................                //apagar actuadores 
....................                      output_high(PIN_C1); 
0D66:  BCF    2E.1
0D67:  MOVF   2E,W
0D68:  BSF    03.5
0D69:  MOVWF  07
0D6A:  BCF    03.5
0D6B:  BSF    07.1
....................                      output_low(PIN_C2); 
0D6C:  BCF    2E.2
0D6D:  MOVF   2E,W
0D6E:  BSF    03.5
0D6F:  MOVWF  07
0D70:  BCF    03.5
0D71:  BCF    07.2
....................                      //led 
....................                      output_high(PIN_C0); 
0D72:  BCF    2E.0
0D73:  MOVF   2E,W
0D74:  BSF    03.5
0D75:  MOVWF  07
0D76:  BCF    03.5
0D77:  BSF    07.0
....................                 
....................                while(true) 
....................                { 
....................                   //Normalmente apagado 
....................                    
....................                   //lectura de temperatura 
....................                   data_ok = DHT11_read_data(&temperatura,&humedad); 
0D78:  CLRF   40
0D79:  MOVLW  31
0D7A:  MOVWF  3F
0D7B:  CLRF   42
0D7C:  MOVLW  39
0D7D:  MOVWF  41
0D7E:  BCF    0A.3
0D7F:  CALL   6AB
0D80:  BSF    0A.3
0D81:  MOVF   78,W
0D82:  MOVWF  30
....................                   //lectura de puerta 
....................                   puerta = input(spuerta); 
0D83:  BSF    03.5
0D84:  BSF    05.1
0D85:  BCF    03.5
0D86:  CLRF   2F
0D87:  BTFSC  05.1
0D88:  INCF   2F,F
....................                   //Imprimir en LCD 
....................                   printf(lcd_putc, "\f"); 
0D89:  MOVLW  0C
0D8A:  MOVWF  4C
0D8B:  BCF    0A.3
0D8C:  CALL   1BB
0D8D:  BSF    0A.3
....................                   lcd_gotoxy(1,1); 
0D8E:  MOVLW  01
0D8F:  MOVWF  4D
0D90:  MOVWF  4E
0D91:  BCF    0A.3
0D92:  CALL   1A9
0D93:  BSF    0A.3
....................                   printf(lcd_putc, "m:Manu"); 
0D94:  MOVLW  9E
0D95:  BSF    03.6
0D96:  MOVWF  0D
0D97:  MOVLW  00
0D98:  MOVWF  0F
0D99:  BCF    0A.3
0D9A:  BCF    03.6
0D9B:  CALL   1E7
0D9C:  BSF    0A.3
....................                    
....................                   if(data_ok == 1) 
0D9D:  DECFSZ 30,W
0D9E:  GOTO   660
....................                   { 
....................                      //calculo de grados centigrados 
....................                      centigrados = (temperatura - 32)*faCentigrados; 
0D9F:  BSF    03.1
0DA0:  MOVF   34,W
0DA1:  MOVWF  64
0DA2:  MOVF   33,W
0DA3:  MOVWF  63
0DA4:  MOVF   32,W
0DA5:  MOVWF  62
0DA6:  MOVF   31,W
0DA7:  MOVWF  61
0DA8:  CLRF   68
0DA9:  CLRF   67
0DAA:  CLRF   66
0DAB:  MOVLW  84
0DAC:  MOVWF  65
0DAD:  BCF    0A.3
0DAE:  CALL   380
0DAF:  BSF    0A.3
0DB0:  MOVF   7A,W
0DB1:  MOVWF  42
0DB2:  MOVF   79,W
0DB3:  MOVWF  41
0DB4:  MOVF   78,W
0DB5:  MOVWF  40
0DB6:  MOVF   77,W
0DB7:  MOVWF  3F
0DB8:  MOVF   7A,W
0DB9:  MOVWF  60
0DBA:  MOVF   79,W
0DBB:  MOVWF  5F
0DBC:  MOVF   78,W
0DBD:  MOVWF  5E
0DBE:  MOVF   77,W
0DBF:  MOVWF  5D
0DC0:  MOVLW  E4
0DC1:  MOVWF  64
0DC2:  MOVLW  38
0DC3:  MOVWF  63
0DC4:  MOVLW  0E
0DC5:  MOVWF  62
0DC6:  MOVLW  7E
0DC7:  MOVWF  61
0DC8:  BCF    0A.3
0DC9:  CALL   2EE
0DCA:  BSF    0A.3
0DCB:  MOVF   7A,W
0DCC:  MOVWF  38
0DCD:  MOVF   79,W
0DCE:  MOVWF  37
0DCF:  MOVF   78,W
0DD0:  MOVWF  36
0DD1:  MOVF   77,W
0DD2:  MOVWF  35
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0DD3:  MOVLW  01
0DD4:  MOVWF  4D
0DD5:  MOVLW  02
0DD6:  MOVWF  4E
0DD7:  BCF    0A.3
0DD8:  CALL   1A9
0DD9:  BSF    0A.3
....................                      printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0DDA:  MOVLW  54
0DDB:  MOVWF  4C
0DDC:  BCF    0A.3
0DDD:  CALL   1BB
0DDE:  BSF    0A.3
0DDF:  MOVLW  3A
0DE0:  MOVWF  4C
0DE1:  BCF    0A.3
0DE2:  CALL   1BB
0DE3:  BSF    0A.3
0DE4:  MOVLW  20
0DE5:  MOVWF  4C
0DE6:  BCF    0A.3
0DE7:  CALL   1BB
0DE8:  BSF    0A.3
0DE9:  MOVLW  89
0DEA:  MOVWF  04
0DEB:  MOVF   38,W
0DEC:  MOVWF  42
0DED:  MOVF   37,W
0DEE:  MOVWF  41
0DEF:  MOVF   36,W
0DF0:  MOVWF  40
0DF1:  MOVF   35,W
0DF2:  MOVWF  3F
0DF3:  MOVLW  01
0DF4:  MOVWF  43
0DF5:  CALL   000
0DF6:  MOVLW  20
0DF7:  MOVWF  4C
0DF8:  BCF    0A.3
0DF9:  CALL   1BB
0DFA:  BSF    0A.3
0DFB:  MOVLW  DF
0DFC:  MOVWF  4C
0DFD:  BCF    0A.3
0DFE:  CALL   1BB
0DFF:  BSF    0A.3
0E00:  MOVLW  43
0E01:  MOVWF  4C
0E02:  BCF    0A.3
0E03:  CALL   1BB
0E04:  BSF    0A.3
....................                      printf("Temperatura (C): %.1f %c   |   Puerta: %u   |   Ventilador: OFF\n\r",centigrados ,223, puerta); 
0E05:  MOVLW  A2
0E06:  BSF    03.6
0E07:  MOVWF  0D
0E08:  MOVLW  00
0E09:  MOVWF  0F
0E0A:  BCF    03.0
0E0B:  MOVLW  11
0E0C:  BCF    03.6
0E0D:  MOVWF  3F
0E0E:  CALL   0D3
0E0F:  MOVLW  89
0E10:  MOVWF  04
0E11:  MOVF   38,W
0E12:  MOVWF  42
0E13:  MOVF   37,W
0E14:  MOVWF  41
0E15:  MOVF   36,W
0E16:  MOVWF  40
0E17:  MOVF   35,W
0E18:  MOVWF  3F
0E19:  MOVLW  01
0E1A:  MOVWF  43
0E1B:  CALL   12C
0E1C:  MOVLW  20
0E1D:  BTFSS  0C.4
0E1E:  GOTO   61D
0E1F:  MOVWF  19
0E20:  MOVLW  DF
0E21:  BTFSS  0C.4
0E22:  GOTO   621
0E23:  MOVWF  19
0E24:  MOVLW  AE
0E25:  BSF    03.6
0E26:  MOVWF  0D
0E27:  MOVLW  00
0E28:  MOVWF  0F
0E29:  BCF    03.0
0E2A:  MOVLW  0F
0E2B:  BCF    03.6
0E2C:  MOVWF  3F
0E2D:  CALL   0D3
0E2E:  MOVF   2F,W
0E2F:  MOVWF  3F
0E30:  MOVLW  1B
0E31:  MOVWF  40
0E32:  CALL   1FB
0E33:  MOVLW  B6
0E34:  BSF    03.6
0E35:  MOVWF  0D
0E36:  MOVLW  00
0E37:  MOVWF  0F
0E38:  BSF    03.0
0E39:  MOVLW  18
0E3A:  BCF    03.6
0E3B:  MOVWF  3F
0E3C:  CALL   0D3
....................                      //ventilador 
....................                      output_low(PIN_C1); 
0E3D:  BCF    2E.1
0E3E:  MOVF   2E,W
0E3F:  BSF    03.5
0E40:  MOVWF  07
0E41:  BCF    03.5
0E42:  BCF    07.1
....................                      output_low(PIN_C2); 
0E43:  BCF    2E.2
0E44:  MOVF   2E,W
0E45:  BSF    03.5
0E46:  MOVWF  07
0E47:  BCF    03.5
0E48:  BCF    07.2
....................                      lcd_gotoxy(12,2); 
0E49:  MOVLW  0C
0E4A:  MOVWF  4D
0E4B:  MOVLW  02
0E4C:  MOVWF  4E
0E4D:  BCF    0A.3
0E4E:  CALL   1A9
0E4F:  BSF    0A.3
....................                      printf(lcd_putc, "V:OFF"); 
0E50:  MOVLW  C3
0E51:  BSF    03.6
0E52:  MOVWF  0D
0E53:  MOVLW  00
0E54:  MOVWF  0F
0E55:  BCF    0A.3
0E56:  BCF    03.6
0E57:  CALL   1E7
0E58:  BSF    0A.3
....................                      //led 
....................                      output_high(PIN_C0); 
0E59:  BCF    2E.0
0E5A:  MOVF   2E,W
0E5B:  BSF    03.5
0E5C:  MOVWF  07
0E5D:  BCF    03.5
0E5E:  BSF    07.0
....................                       
....................                       
....................                   }else{ 
0E5F:  GOTO   677
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0E60:  MOVLW  01
0E61:  MOVWF  4D
0E62:  MOVLW  02
0E63:  MOVWF  4E
0E64:  BCF    0A.3
0E65:  CALL   1A9
0E66:  BSF    0A.3
....................                      printf(lcd_putc, "T:NA"); 
0E67:  MOVLW  C6
0E68:  BSF    03.6
0E69:  MOVWF  0D
0E6A:  MOVLW  00
0E6B:  MOVWF  0F
0E6C:  BCF    0A.3
0E6D:  BCF    03.6
0E6E:  CALL   1E7
0E6F:  BSF    0A.3
....................                      printf("DESCONECTADO\n\r"); 
0E70:  MOVLW  C9
0E71:  BSF    03.6
0E72:  MOVWF  0D
0E73:  MOVLW  00
0E74:  MOVWF  0F
0E75:  BCF    03.6
0E76:  CALL   237
....................                   } 
....................                    
....................                   //encender o salir 
....................                   salir = getch(); 
0E77:  BCF    0A.3
0E78:  CALL   23D
0E79:  BSF    0A.3
0E7A:  MOVF   78,W
0E7B:  MOVWF  3E
....................                   if(salir == 'c' || salir == 's') 
0E7C:  MOVF   3E,W
0E7D:  SUBLW  63
0E7E:  BTFSC  03.2
0E7F:  GOTO   683
0E80:  MOVF   3E,W
0E81:  SUBLW  73
0E82:  BTFSC  03.2
....................                   { 
....................                      break; 
0E83:  GOTO   68E
....................                   } 
....................                   delay_ms(1500); 
0E84:  MOVLW  06
0E85:  MOVWF  3F
0E86:  MOVLW  FA
0E87:  MOVWF  4D
0E88:  BCF    0A.3
0E89:  CALL   104
0E8A:  BSF    0A.3
0E8B:  DECFSZ 3F,F
0E8C:  GOTO   686
0E8D:  GOTO   578
....................                    
....................                } 
....................                if(salir == 's'){ 
0E8E:  MOVF   3E,W
0E8F:  SUBLW  73
0E90:  BTFSC  03.2
....................                   break; 
0E91:  GOTO   7AD
....................                } 
....................                while(true) 
....................                { 
....................                    
....................                    
....................                    
....................                   //Normalmente encendido 
....................                    
....................                   //lectura de temperatura 
....................                   data_ok = DHT11_read_data(&temperatura,&humedad); 
0E92:  CLRF   40
0E93:  MOVLW  31
0E94:  MOVWF  3F
0E95:  CLRF   42
0E96:  MOVLW  39
0E97:  MOVWF  41
0E98:  BCF    0A.3
0E99:  CALL   6AB
0E9A:  BSF    0A.3
0E9B:  MOVF   78,W
0E9C:  MOVWF  30
....................                   //lectura de puerta 
....................                   puerta = input(spuerta); 
0E9D:  BSF    03.5
0E9E:  BSF    05.1
0E9F:  BCF    03.5
0EA0:  CLRF   2F
0EA1:  BTFSC  05.1
0EA2:  INCF   2F,F
....................                   //Imprimir en LCD 
....................                   printf(lcd_putc, "\f"); 
0EA3:  MOVLW  0C
0EA4:  MOVWF  4C
0EA5:  BCF    0A.3
0EA6:  CALL   1BB
0EA7:  BSF    0A.3
....................                   lcd_gotoxy(1,1); 
0EA8:  MOVLW  01
0EA9:  MOVWF  4D
0EAA:  MOVWF  4E
0EAB:  BCF    0A.3
0EAC:  CALL   1A9
0EAD:  BSF    0A.3
....................                   printf(lcd_putc, "m:Manu"); 
0EAE:  MOVLW  D1
0EAF:  BSF    03.6
0EB0:  MOVWF  0D
0EB1:  MOVLW  00
0EB2:  MOVWF  0F
0EB3:  BCF    0A.3
0EB4:  BCF    03.6
0EB5:  CALL   1E7
0EB6:  BSF    0A.3
....................                    
....................                   if(data_ok == 1) 
0EB7:  DECFSZ 30,W
0EB8:  GOTO   77A
....................                   { 
....................                      //calculo de grados centigrados 
....................                      centigrados = (temperatura - 32)*faCentigrados; 
0EB9:  BSF    03.1
0EBA:  MOVF   34,W
0EBB:  MOVWF  64
0EBC:  MOVF   33,W
0EBD:  MOVWF  63
0EBE:  MOVF   32,W
0EBF:  MOVWF  62
0EC0:  MOVF   31,W
0EC1:  MOVWF  61
0EC2:  CLRF   68
0EC3:  CLRF   67
0EC4:  CLRF   66
0EC5:  MOVLW  84
0EC6:  MOVWF  65
0EC7:  BCF    0A.3
0EC8:  CALL   380
0EC9:  BSF    0A.3
0ECA:  MOVF   7A,W
0ECB:  MOVWF  42
0ECC:  MOVF   79,W
0ECD:  MOVWF  41
0ECE:  MOVF   78,W
0ECF:  MOVWF  40
0ED0:  MOVF   77,W
0ED1:  MOVWF  3F
0ED2:  MOVF   7A,W
0ED3:  MOVWF  60
0ED4:  MOVF   79,W
0ED5:  MOVWF  5F
0ED6:  MOVF   78,W
0ED7:  MOVWF  5E
0ED8:  MOVF   77,W
0ED9:  MOVWF  5D
0EDA:  MOVLW  E4
0EDB:  MOVWF  64
0EDC:  MOVLW  38
0EDD:  MOVWF  63
0EDE:  MOVLW  0E
0EDF:  MOVWF  62
0EE0:  MOVLW  7E
0EE1:  MOVWF  61
0EE2:  BCF    0A.3
0EE3:  CALL   2EE
0EE4:  BSF    0A.3
0EE5:  MOVF   7A,W
0EE6:  MOVWF  38
0EE7:  MOVF   79,W
0EE8:  MOVWF  37
0EE9:  MOVF   78,W
0EEA:  MOVWF  36
0EEB:  MOVF   77,W
0EEC:  MOVWF  35
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0EED:  MOVLW  01
0EEE:  MOVWF  4D
0EEF:  MOVLW  02
0EF0:  MOVWF  4E
0EF1:  BCF    0A.3
0EF2:  CALL   1A9
0EF3:  BSF    0A.3
....................                      printf(lcd_putc, "T: %.1f %CC", centigrados, 223); 
0EF4:  MOVLW  54
0EF5:  MOVWF  4C
0EF6:  BCF    0A.3
0EF7:  CALL   1BB
0EF8:  BSF    0A.3
0EF9:  MOVLW  3A
0EFA:  MOVWF  4C
0EFB:  BCF    0A.3
0EFC:  CALL   1BB
0EFD:  BSF    0A.3
0EFE:  MOVLW  20
0EFF:  MOVWF  4C
0F00:  BCF    0A.3
0F01:  CALL   1BB
0F02:  BSF    0A.3
0F03:  MOVLW  89
0F04:  MOVWF  04
0F05:  MOVF   38,W
0F06:  MOVWF  42
0F07:  MOVF   37,W
0F08:  MOVWF  41
0F09:  MOVF   36,W
0F0A:  MOVWF  40
0F0B:  MOVF   35,W
0F0C:  MOVWF  3F
0F0D:  MOVLW  01
0F0E:  MOVWF  43
0F0F:  CALL   000
0F10:  MOVLW  20
0F11:  MOVWF  4C
0F12:  BCF    0A.3
0F13:  CALL   1BB
0F14:  BSF    0A.3
0F15:  MOVLW  DF
0F16:  MOVWF  4C
0F17:  BCF    0A.3
0F18:  CALL   1BB
0F19:  BSF    0A.3
0F1A:  MOVLW  43
0F1B:  MOVWF  4C
0F1C:  BCF    0A.3
0F1D:  CALL   1BB
0F1E:  BSF    0A.3
....................                      printf("Temperatura (C): %.1f %c   |   Puerta: %u   |   Ventilador: ON\n\r",centigrados ,223, puerta); 
0F1F:  MOVLW  D5
0F20:  BSF    03.6
0F21:  MOVWF  0D
0F22:  MOVLW  00
0F23:  MOVWF  0F
0F24:  BCF    03.0
0F25:  MOVLW  11
0F26:  BCF    03.6
0F27:  MOVWF  3F
0F28:  CALL   0D3
0F29:  MOVLW  89
0F2A:  MOVWF  04
0F2B:  MOVF   38,W
0F2C:  MOVWF  42
0F2D:  MOVF   37,W
0F2E:  MOVWF  41
0F2F:  MOVF   36,W
0F30:  MOVWF  40
0F31:  MOVF   35,W
0F32:  MOVWF  3F
0F33:  MOVLW  01
0F34:  MOVWF  43
0F35:  CALL   12C
0F36:  MOVLW  20
0F37:  BTFSS  0C.4
0F38:  GOTO   737
0F39:  MOVWF  19
0F3A:  MOVLW  DF
0F3B:  BTFSS  0C.4
0F3C:  GOTO   73B
0F3D:  MOVWF  19
0F3E:  MOVLW  E1
0F3F:  BSF    03.6
0F40:  MOVWF  0D
0F41:  MOVLW  00
0F42:  MOVWF  0F
0F43:  BCF    03.0
0F44:  MOVLW  0F
0F45:  BCF    03.6
0F46:  MOVWF  3F
0F47:  CALL   0D3
0F48:  MOVF   2F,W
0F49:  MOVWF  3F
0F4A:  MOVLW  1B
0F4B:  MOVWF  40
0F4C:  CALL   1FB
0F4D:  MOVLW  E9
0F4E:  BSF    03.6
0F4F:  MOVWF  0D
0F50:  MOVLW  00
0F51:  MOVWF  0F
0F52:  BSF    03.0
0F53:  MOVLW  17
0F54:  BCF    03.6
0F55:  MOVWF  3F
0F56:  CALL   0D3
....................                      //ventilador 
....................                      output_high(PIN_C1); 
0F57:  BCF    2E.1
0F58:  MOVF   2E,W
0F59:  BSF    03.5
0F5A:  MOVWF  07
0F5B:  BCF    03.5
0F5C:  BSF    07.1
....................                      output_low(PIN_C2); 
0F5D:  BCF    2E.2
0F5E:  MOVF   2E,W
0F5F:  BSF    03.5
0F60:  MOVWF  07
0F61:  BCF    03.5
0F62:  BCF    07.2
....................                      //led 
....................                      output_high(PIN_C0); 
0F63:  BCF    2E.0
0F64:  MOVF   2E,W
0F65:  BSF    03.5
0F66:  MOVWF  07
0F67:  BCF    03.5
0F68:  BSF    07.0
....................                      lcd_gotoxy(12,2); 
0F69:  MOVLW  0C
0F6A:  MOVWF  4D
0F6B:  MOVLW  02
0F6C:  MOVWF  4E
0F6D:  BCF    0A.3
0F6E:  CALL   1A9
0F6F:  BSF    0A.3
....................                      printf(lcd_putc, "V:ON"); 
0F70:  MOVLW  F6
0F71:  BSF    03.6
0F72:  MOVWF  0D
0F73:  MOVLW  00
0F74:  MOVWF  0F
0F75:  BCF    0A.3
0F76:  BCF    03.6
0F77:  CALL   1E7
0F78:  BSF    0A.3
....................                       
....................                       
....................                   }else{ 
0F79:  GOTO   791
....................                      //salidas 
....................                      lcd_gotoxy(1,2); 
0F7A:  MOVLW  01
0F7B:  MOVWF  4D
0F7C:  MOVLW  02
0F7D:  MOVWF  4E
0F7E:  BCF    0A.3
0F7F:  CALL   1A9
0F80:  BSF    0A.3
....................                      printf(lcd_putc, "T:NA"); 
0F81:  MOVLW  F9
0F82:  BSF    03.6
0F83:  MOVWF  0D
0F84:  MOVLW  00
0F85:  MOVWF  0F
0F86:  BCF    0A.3
0F87:  BCF    03.6
0F88:  CALL   1E7
0F89:  BSF    0A.3
....................                      printf("DESCONECTADO\n\r"); 
0F8A:  MOVLW  FC
0F8B:  BSF    03.6
0F8C:  MOVWF  0D
0F8D:  MOVLW  00
0F8E:  MOVWF  0F
0F8F:  BCF    03.6
0F90:  CALL   237
....................                   } 
....................                    
....................                    
....................                    
....................                    
....................                    
....................                   //apagar o salir 
....................                   salir = getch(); 
0F91:  BCF    0A.3
0F92:  CALL   23D
0F93:  BSF    0A.3
0F94:  MOVF   78,W
0F95:  MOVWF  3E
....................                   if(salir == 'c' || salir == 's') 
0F96:  MOVF   3E,W
0F97:  SUBLW  63
0F98:  BTFSC  03.2
0F99:  GOTO   79D
0F9A:  MOVF   3E,W
0F9B:  SUBLW  73
0F9C:  BTFSC  03.2
....................                   { 
....................                      break; 
0F9D:  GOTO   7A8
....................                   } 
....................                   delay_ms(1500); 
0F9E:  MOVLW  06
0F9F:  MOVWF  3F
0FA0:  MOVLW  FA
0FA1:  MOVWF  4D
0FA2:  BCF    0A.3
0FA3:  CALL   104
0FA4:  BSF    0A.3
0FA5:  DECFSZ 3F,F
0FA6:  GOTO   7A0
0FA7:  GOTO   692
....................                } 
....................                if(salir == 's'){ 
0FA8:  MOVF   3E,W
0FA9:  SUBLW  73
0FAA:  BTFSC  03.2
....................                   break; 
0FAB:  GOTO   7AD
....................                } 
0FAC:  GOTO   566
....................                 
....................             } 
....................                 
....................              
....................                       
....................           
....................           
....................          } 
....................                 
....................       } 
0FAD:  GOTO   2D1
....................        
....................        
....................       
....................        
....................        
....................       
....................    } 
.................... } 
0FAE:  SLEEP

Configuration Fuses:
   Word  1: 2CA4   INTRC_IO NOWDT PUT MCLR PROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
